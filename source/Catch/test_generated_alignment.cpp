#include "Catch/catch.hpp"
#include "Catch/picojson.h"
#include "Catch/catchhelperfunctions.h"

#include "trimalArgumentParser.h"
#include "Matchers/ArrayMatcher.cpp"
#include <vector>

#include <fstream>

int i;

// Map of old and new ID's of sequence types
std::map<int,int> AlignmentTypeCorrespondence = {
        {1, SequenceTypes::DNA},
        {2, SequenceTypes::RNA},
        {3, SequenceTypes::AA},
        {4, SequenceTypes::DNA | SequenceTypes::DEG},
        {5, SequenceTypes::RNA | SequenceTypes::DEG}
};

// tag input_filename will be replaced for each name in ./database
// EndOfHeader // <- Do not remove this comment, as is used by TestMaker.
SCENARIO ("Alignment methods work correctly in alignments_comparison.1", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("alignments_comparison.1", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/alignments_comparison.1.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/alignments_comparison.1.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/alignments_comparison.1.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/alignments_comparison.1.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/alignments_comparison.1.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/alignments_comparison.1.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/alignments_comparison.1.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/alignments_comparison.1.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/alignments_comparison.1.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/alignments_comparison.1.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/alignments_comparison.1.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/alignments_comparison.1.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/alignments_comparison.1.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/alignments_comparison.1.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/alignments_comparison.1.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from alignments_comparison.1");

}

SCENARIO ("Alignment methods work correctly in alignments_comparison.2", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("alignments_comparison.2", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/alignments_comparison.2.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/alignments_comparison.2.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/alignments_comparison.2.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/alignments_comparison.2.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/alignments_comparison.2.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/alignments_comparison.2.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/alignments_comparison.2.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/alignments_comparison.2.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/alignments_comparison.2.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/alignments_comparison.2.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/alignments_comparison.2.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/alignments_comparison.2.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/alignments_comparison.2.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/alignments_comparison.2.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/alignments_comparison.2.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from alignments_comparison.2");

}

SCENARIO ("Alignment methods work correctly in alignments_comparison.3", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("alignments_comparison.3", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/alignments_comparison.3.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/alignments_comparison.3.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/alignments_comparison.3.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/alignments_comparison.3.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/alignments_comparison.3.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/alignments_comparison.3.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/alignments_comparison.3.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/alignments_comparison.3.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/alignments_comparison.3.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/alignments_comparison.3.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/alignments_comparison.3.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/alignments_comparison.3.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/alignments_comparison.3.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/alignments_comparison.3.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/alignments_comparison.3.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from alignments_comparison.3");

}

SCENARIO ("Alignment methods work correctly in example.001.AA.clw", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.001.AA.clw", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.001.AA.clw.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.001.AA.clw.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.001.AA.clw.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.001.AA.clw.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.001.AA.clw.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.001.AA.clw.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.001.AA.clw.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.001.AA.clw.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.001.AA.clw.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.001.AA.clw.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.001.AA.clw.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.001.AA.clw.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.001.AA.clw.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.001.AA.clw.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.001.AA.clw.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.001.AA.clw");

}

SCENARIO ("Alignment methods work correctly in example.001.AA.msl", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.001.AA.msl", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.001.AA.msl.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.001.AA.msl.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.001.AA.msl.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.001.AA.msl.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.001.AA.msl.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.001.AA.msl.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.001.AA.msl.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.001.AA.msl.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.001.AA.msl.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.001.AA.msl.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.001.AA.msl.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.001.AA.msl.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.001.AA.msl.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.001.AA.msl.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.001.AA.msl.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.001.AA.msl");

}

SCENARIO ("Alignment methods work correctly in example.001.AA.phy", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.001.AA.phy", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.001.AA.phy.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.001.AA.phy.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.001.AA.phy.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.001.AA.phy.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.001.AA.phy.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.001.AA.phy.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.001.AA.phy.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.001.AA.phy.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.001.AA.phy.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.001.AA.phy.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.001.AA.phy.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.001.AA.phy.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.001.AA.phy.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.001.AA.phy.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.001.AA.phy.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.001.AA.phy");

}

SCENARIO ("Alignment methods work correctly in example.002.AA.clw", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.002.AA.clw", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.002.AA.clw.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.002.AA.clw.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.002.AA.clw.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.002.AA.clw.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.002.AA.clw.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.002.AA.clw.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.002.AA.clw.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.002.AA.clw.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.002.AA.clw.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.002.AA.clw.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.002.AA.clw.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.002.AA.clw.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.002.AA.clw.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.002.AA.clw.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.002.AA.clw.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.002.AA.clw");

}

SCENARIO ("Alignment methods work correctly in example.002.AA.phy", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.002.AA.phy", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.002.AA.phy.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.002.AA.phy.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.002.AA.phy.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.002.AA.phy.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.002.AA.phy.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.002.AA.phy.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.002.AA.phy.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.002.AA.phy.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.002.AA.phy.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.002.AA.phy.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.002.AA.phy.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.002.AA.phy.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.002.AA.phy.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.002.AA.phy.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.002.AA.phy.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.002.AA.phy");

}

SCENARIO ("Alignment methods work correctly in example.003.AA.clw", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.003.AA.clw", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.003.AA.clw.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.003.AA.clw.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.003.AA.clw.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.003.AA.clw.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.003.AA.clw.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.003.AA.clw.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.003.AA.clw.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.003.AA.clw.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.003.AA.clw.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.003.AA.clw.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.003.AA.clw.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.003.AA.clw.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.003.AA.clw.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.003.AA.clw.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.003.AA.clw.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.003.AA.clw");

}

SCENARIO ("Alignment methods work correctly in example.004.AA.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.004.AA.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.004.AA.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.004.AA.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.004.AA.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.004.AA.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.004.AA.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.004.AA.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.004.AA.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.004.AA.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.004.AA.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.004.AA.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.004.AA.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.004.AA.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.004.AA.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.004.AA.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.004.AA.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.004.AA.fasta");

}

SCENARIO ("Alignment methods work correctly in example.005.AA.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.005.AA.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.005.AA.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.005.AA.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.005.AA.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.005.AA.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.005.AA.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.005.AA.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.005.AA.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.005.AA.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.005.AA.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.005.AA.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.005.AA.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.005.AA.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.005.AA.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.005.AA.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.005.AA.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.005.AA.fasta");

}

SCENARIO ("Alignment methods work correctly in example.006.AA.pir", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.006.AA.pir", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.006.AA.pir.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.006.AA.pir.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.006.AA.pir.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.006.AA.pir.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.006.AA.pir.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.006.AA.pir.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.006.AA.pir.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.006.AA.pir.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.006.AA.pir.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.006.AA.pir.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.006.AA.pir.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.006.AA.pir.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.006.AA.pir.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.006.AA.pir.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.006.AA.pir.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.006.AA.pir");

}

SCENARIO ("Alignment methods work correctly in example.007.AA.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.007.AA.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.007.AA.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.007.AA.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.007.AA.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.007.AA.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.007.AA.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.007.AA.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.007.AA.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.007.AA.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.007.AA.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.007.AA.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.007.AA.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.007.AA.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.007.AA.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.007.AA.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.007.AA.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.007.AA.fasta");

}

SCENARIO ("Alignment methods work correctly in example.007.AA.only_seqs", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.007.AA.only_seqs", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.007.AA.only_seqs.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.007.AA.only_seqs.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.007.AA.only_seqs.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.007.AA.only_seqs.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.007.AA.only_seqs.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.007.AA.only_seqs.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.007.AA.only_seqs.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.007.AA.only_seqs.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.007.AA.only_seqs.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.007.AA.only_seqs.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.007.AA.only_seqs.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.007.AA.only_seqs.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.007.AA.only_seqs.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.007.AA.only_seqs.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.007.AA.only_seqs.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.007.AA.only_seqs");

}

SCENARIO ("Alignment methods work correctly in example.009.AA.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.009.AA.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.009.AA.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.009.AA.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.009.AA.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.009.AA.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.009.AA.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.009.AA.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.009.AA.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.009.AA.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.009.AA.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.009.AA.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.009.AA.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.009.AA.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.009.AA.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.009.AA.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.009.AA.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.009.AA.fasta");

}

SCENARIO ("Alignment methods work correctly in example.010.AA.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.010.AA.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.010.AA.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.010.AA.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.010.AA.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.010.AA.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.010.AA.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.010.AA.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.010.AA.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.010.AA.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.010.AA.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.010.AA.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.010.AA.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.010.AA.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.010.AA.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.010.AA.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.010.AA.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.010.AA.fasta");

}

SCENARIO ("Alignment methods work correctly in example.011.AA.YKL197C.clw", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.011.AA.YKL197C.clw", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.clw.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.clw.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.clw.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.clw.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.clw.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.clw.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.clw.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.clw.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.clw.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.clw.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.clw.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.clw.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.clw.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.clw.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.clw.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.011.AA.YKL197C.clw");

}

SCENARIO ("Alignment methods work correctly in example.011.AA.YKL197C.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.011.AA.YKL197C.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.011.AA.YKL197C.fasta");

}

SCENARIO ("Alignment methods work correctly in example.011.AA.YKL197C.phy", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.011.AA.YKL197C.phy", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.phy.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.phy.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.phy.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.phy.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.phy.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.phy.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.phy.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.phy.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.phy.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.phy.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.phy.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.phy.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.phy.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.phy.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.011.AA.YKL197C.phy.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.011.AA.YKL197C.phy");

}

SCENARIO ("Alignment methods work correctly in example.012.AA.SuperAlignment.phy", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.012.AA.SuperAlignment.phy", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.012.AA.SuperAlignment.phy.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.012.AA.SuperAlignment.phy.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.012.AA.SuperAlignment.phy.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.012.AA.SuperAlignment.phy.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.012.AA.SuperAlignment.phy.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.012.AA.SuperAlignment.phy.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.012.AA.SuperAlignment.phy.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.012.AA.SuperAlignment.phy.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.012.AA.SuperAlignment.phy.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.012.AA.SuperAlignment.phy.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.012.AA.SuperAlignment.phy.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.012.AA.SuperAlignment.phy.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.012.AA.SuperAlignment.phy.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.012.AA.SuperAlignment.phy.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.012.AA.SuperAlignment.phy.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.012.AA.SuperAlignment.phy");

}

SCENARIO ("Alignment methods work correctly in example.013.AA.SuperAlignment.phy", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.013.AA.SuperAlignment.phy", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.013.AA.SuperAlignment.phy.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.013.AA.SuperAlignment.phy.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.013.AA.SuperAlignment.phy.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.013.AA.SuperAlignment.phy.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.013.AA.SuperAlignment.phy.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.013.AA.SuperAlignment.phy.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.013.AA.SuperAlignment.phy.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.013.AA.SuperAlignment.phy.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.013.AA.SuperAlignment.phy.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.013.AA.SuperAlignment.phy.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.013.AA.SuperAlignment.phy.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.013.AA.SuperAlignment.phy.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.013.AA.SuperAlignment.phy.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.013.AA.SuperAlignment.phy.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.013.AA.SuperAlignment.phy.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.013.AA.SuperAlignment.phy");

}

SCENARIO ("Alignment methods work correctly in example.014.AA.EggNOG.COG0591.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.014.AA.EggNOG.COG0591.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.014.AA.EggNOG.COG0591.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.014.AA.EggNOG.COG0591.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.014.AA.EggNOG.COG0591.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.014.AA.EggNOG.COG0591.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.014.AA.EggNOG.COG0591.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.014.AA.EggNOG.COG0591.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.014.AA.EggNOG.COG0591.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.014.AA.EggNOG.COG0591.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.014.AA.EggNOG.COG0591.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.014.AA.EggNOG.COG0591.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.014.AA.EggNOG.COG0591.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.014.AA.EggNOG.COG0591.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.014.AA.EggNOG.COG0591.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.014.AA.EggNOG.COG0591.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.014.AA.EggNOG.COG0591.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.014.AA.EggNOG.COG0591.fasta");

}

SCENARIO ("Alignment methods work correctly in example.015.AA.bctoNOG.ENOG41099F3.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.015.AA.bctoNOG.ENOG41099F3.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.015.AA.bctoNOG.ENOG41099F3.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.015.AA.bctoNOG.ENOG41099F3.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.015.AA.bctoNOG.ENOG41099F3.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.015.AA.bctoNOG.ENOG41099F3.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.015.AA.bctoNOG.ENOG41099F3.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.015.AA.bctoNOG.ENOG41099F3.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.015.AA.bctoNOG.ENOG41099F3.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.015.AA.bctoNOG.ENOG41099F3.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.015.AA.bctoNOG.ENOG41099F3.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.015.AA.bctoNOG.ENOG41099F3.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.015.AA.bctoNOG.ENOG41099F3.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.015.AA.bctoNOG.ENOG41099F3.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.015.AA.bctoNOG.ENOG41099F3.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.015.AA.bctoNOG.ENOG41099F3.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.015.AA.bctoNOG.ENOG41099F3.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.015.AA.bctoNOG.ENOG41099F3.fasta");

}

SCENARIO ("Alignment methods work correctly in example.016.AA.bctoNOG.ENOG41099FB.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.016.AA.bctoNOG.ENOG41099FB.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.016.AA.bctoNOG.ENOG41099FB.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.016.AA.bctoNOG.ENOG41099FB.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.016.AA.bctoNOG.ENOG41099FB.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.016.AA.bctoNOG.ENOG41099FB.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.016.AA.bctoNOG.ENOG41099FB.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.016.AA.bctoNOG.ENOG41099FB.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.016.AA.bctoNOG.ENOG41099FB.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.016.AA.bctoNOG.ENOG41099FB.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.016.AA.bctoNOG.ENOG41099FB.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.016.AA.bctoNOG.ENOG41099FB.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.016.AA.bctoNOG.ENOG41099FB.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.016.AA.bctoNOG.ENOG41099FB.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.016.AA.bctoNOG.ENOG41099FB.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.016.AA.bctoNOG.ENOG41099FB.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.016.AA.bctoNOG.ENOG41099FB.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.016.AA.bctoNOG.ENOG41099FB.fasta");

}

SCENARIO ("Alignment methods work correctly in example.017.AA.bctoNOG.ENOG41099FJ.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.017.AA.bctoNOG.ENOG41099FJ.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.017.AA.bctoNOG.ENOG41099FJ.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.017.AA.bctoNOG.ENOG41099FJ.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.017.AA.bctoNOG.ENOG41099FJ.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.017.AA.bctoNOG.ENOG41099FJ.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.017.AA.bctoNOG.ENOG41099FJ.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.017.AA.bctoNOG.ENOG41099FJ.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.017.AA.bctoNOG.ENOG41099FJ.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.017.AA.bctoNOG.ENOG41099FJ.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.017.AA.bctoNOG.ENOG41099FJ.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.017.AA.bctoNOG.ENOG41099FJ.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.017.AA.bctoNOG.ENOG41099FJ.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.017.AA.bctoNOG.ENOG41099FJ.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.017.AA.bctoNOG.ENOG41099FJ.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.017.AA.bctoNOG.ENOG41099FJ.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.017.AA.bctoNOG.ENOG41099FJ.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.017.AA.bctoNOG.ENOG41099FJ.fasta");

}

SCENARIO ("Alignment methods work correctly in example.018.AA.bctoNOG.ENOG41099FV.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.018.AA.bctoNOG.ENOG41099FV.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.018.AA.bctoNOG.ENOG41099FV.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.018.AA.bctoNOG.ENOG41099FV.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.018.AA.bctoNOG.ENOG41099FV.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.018.AA.bctoNOG.ENOG41099FV.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.018.AA.bctoNOG.ENOG41099FV.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.018.AA.bctoNOG.ENOG41099FV.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.018.AA.bctoNOG.ENOG41099FV.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.018.AA.bctoNOG.ENOG41099FV.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.018.AA.bctoNOG.ENOG41099FV.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.018.AA.bctoNOG.ENOG41099FV.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.018.AA.bctoNOG.ENOG41099FV.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.018.AA.bctoNOG.ENOG41099FV.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.018.AA.bctoNOG.ENOG41099FV.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.018.AA.bctoNOG.ENOG41099FV.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.018.AA.bctoNOG.ENOG41099FV.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.018.AA.bctoNOG.ENOG41099FV.fasta");

}

SCENARIO ("Alignment methods work correctly in example.019.AA.bctoNOG.ENOG41099HI.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.019.AA.bctoNOG.ENOG41099HI.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.019.AA.bctoNOG.ENOG41099HI.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.019.AA.bctoNOG.ENOG41099HI.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.019.AA.bctoNOG.ENOG41099HI.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.019.AA.bctoNOG.ENOG41099HI.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.019.AA.bctoNOG.ENOG41099HI.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.019.AA.bctoNOG.ENOG41099HI.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.019.AA.bctoNOG.ENOG41099HI.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.019.AA.bctoNOG.ENOG41099HI.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.019.AA.bctoNOG.ENOG41099HI.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.019.AA.bctoNOG.ENOG41099HI.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.019.AA.bctoNOG.ENOG41099HI.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.019.AA.bctoNOG.ENOG41099HI.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.019.AA.bctoNOG.ENOG41099HI.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.019.AA.bctoNOG.ENOG41099HI.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.019.AA.bctoNOG.ENOG41099HI.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.019.AA.bctoNOG.ENOG41099HI.fasta");

}

SCENARIO ("Alignment methods work correctly in example.020.AA.bctoNOG.ENOG41099HN.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.020.AA.bctoNOG.ENOG41099HN.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.020.AA.bctoNOG.ENOG41099HN.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.020.AA.bctoNOG.ENOG41099HN.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.020.AA.bctoNOG.ENOG41099HN.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.020.AA.bctoNOG.ENOG41099HN.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.020.AA.bctoNOG.ENOG41099HN.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.020.AA.bctoNOG.ENOG41099HN.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.020.AA.bctoNOG.ENOG41099HN.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.020.AA.bctoNOG.ENOG41099HN.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.020.AA.bctoNOG.ENOG41099HN.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.020.AA.bctoNOG.ENOG41099HN.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.020.AA.bctoNOG.ENOG41099HN.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.020.AA.bctoNOG.ENOG41099HN.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.020.AA.bctoNOG.ENOG41099HN.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.020.AA.bctoNOG.ENOG41099HN.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.020.AA.bctoNOG.ENOG41099HN.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.020.AA.bctoNOG.ENOG41099HN.fasta");

}

SCENARIO ("Alignment methods work correctly in example.021.AA.bctoNOG.ENOG41099I5.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.021.AA.bctoNOG.ENOG41099I5.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.021.AA.bctoNOG.ENOG41099I5.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.021.AA.bctoNOG.ENOG41099I5.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.021.AA.bctoNOG.ENOG41099I5.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.021.AA.bctoNOG.ENOG41099I5.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.021.AA.bctoNOG.ENOG41099I5.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.021.AA.bctoNOG.ENOG41099I5.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.021.AA.bctoNOG.ENOG41099I5.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.021.AA.bctoNOG.ENOG41099I5.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.021.AA.bctoNOG.ENOG41099I5.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.021.AA.bctoNOG.ENOG41099I5.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.021.AA.bctoNOG.ENOG41099I5.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.021.AA.bctoNOG.ENOG41099I5.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.021.AA.bctoNOG.ENOG41099I5.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.021.AA.bctoNOG.ENOG41099I5.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.021.AA.bctoNOG.ENOG41099I5.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.021.AA.bctoNOG.ENOG41099I5.fasta");

}

SCENARIO ("Alignment methods work correctly in example.022.AA.bctoNOG.ENOG41099IZ.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.022.AA.bctoNOG.ENOG41099IZ.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.022.AA.bctoNOG.ENOG41099IZ.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.022.AA.bctoNOG.ENOG41099IZ.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.022.AA.bctoNOG.ENOG41099IZ.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.022.AA.bctoNOG.ENOG41099IZ.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.022.AA.bctoNOG.ENOG41099IZ.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.022.AA.bctoNOG.ENOG41099IZ.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.022.AA.bctoNOG.ENOG41099IZ.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.022.AA.bctoNOG.ENOG41099IZ.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.022.AA.bctoNOG.ENOG41099IZ.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.022.AA.bctoNOG.ENOG41099IZ.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.022.AA.bctoNOG.ENOG41099IZ.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.022.AA.bctoNOG.ENOG41099IZ.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.022.AA.bctoNOG.ENOG41099IZ.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.022.AA.bctoNOG.ENOG41099IZ.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.022.AA.bctoNOG.ENOG41099IZ.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.022.AA.bctoNOG.ENOG41099IZ.fasta");

}

SCENARIO ("Alignment methods work correctly in example.023.AA.bctoNOG.ENOG41099K3.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.023.AA.bctoNOG.ENOG41099K3.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.023.AA.bctoNOG.ENOG41099K3.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.023.AA.bctoNOG.ENOG41099K3.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.023.AA.bctoNOG.ENOG41099K3.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.023.AA.bctoNOG.ENOG41099K3.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.023.AA.bctoNOG.ENOG41099K3.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.023.AA.bctoNOG.ENOG41099K3.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.023.AA.bctoNOG.ENOG41099K3.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.023.AA.bctoNOG.ENOG41099K3.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.023.AA.bctoNOG.ENOG41099K3.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.023.AA.bctoNOG.ENOG41099K3.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.023.AA.bctoNOG.ENOG41099K3.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.023.AA.bctoNOG.ENOG41099K3.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.023.AA.bctoNOG.ENOG41099K3.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.023.AA.bctoNOG.ENOG41099K3.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.023.AA.bctoNOG.ENOG41099K3.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.023.AA.bctoNOG.ENOG41099K3.fasta");

}

SCENARIO ("Alignment methods work correctly in example.024.AA.bctoNOG.ENOG41099KM.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.024.AA.bctoNOG.ENOG41099KM.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.024.AA.bctoNOG.ENOG41099KM.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.024.AA.bctoNOG.ENOG41099KM.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.024.AA.bctoNOG.ENOG41099KM.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.024.AA.bctoNOG.ENOG41099KM.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.024.AA.bctoNOG.ENOG41099KM.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.024.AA.bctoNOG.ENOG41099KM.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.024.AA.bctoNOG.ENOG41099KM.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.024.AA.bctoNOG.ENOG41099KM.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.024.AA.bctoNOG.ENOG41099KM.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.024.AA.bctoNOG.ENOG41099KM.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.024.AA.bctoNOG.ENOG41099KM.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.024.AA.bctoNOG.ENOG41099KM.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.024.AA.bctoNOG.ENOG41099KM.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.024.AA.bctoNOG.ENOG41099KM.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.024.AA.bctoNOG.ENOG41099KM.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.024.AA.bctoNOG.ENOG41099KM.fasta");

}

SCENARIO ("Alignment methods work correctly in example.025.AA.bctoNOG.ENOG41099KP.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.025.AA.bctoNOG.ENOG41099KP.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.025.AA.bctoNOG.ENOG41099KP.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.025.AA.bctoNOG.ENOG41099KP.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.025.AA.bctoNOG.ENOG41099KP.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.025.AA.bctoNOG.ENOG41099KP.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.025.AA.bctoNOG.ENOG41099KP.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.025.AA.bctoNOG.ENOG41099KP.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.025.AA.bctoNOG.ENOG41099KP.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.025.AA.bctoNOG.ENOG41099KP.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.025.AA.bctoNOG.ENOG41099KP.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.025.AA.bctoNOG.ENOG41099KP.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.025.AA.bctoNOG.ENOG41099KP.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.025.AA.bctoNOG.ENOG41099KP.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.025.AA.bctoNOG.ENOG41099KP.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.025.AA.bctoNOG.ENOG41099KP.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.025.AA.bctoNOG.ENOG41099KP.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.025.AA.bctoNOG.ENOG41099KP.fasta");

}

SCENARIO ("Alignment methods work correctly in example.026.AA.bctoNOG.ENOG41099MV.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.026.AA.bctoNOG.ENOG41099MV.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.026.AA.bctoNOG.ENOG41099MV.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.026.AA.bctoNOG.ENOG41099MV.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.026.AA.bctoNOG.ENOG41099MV.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.026.AA.bctoNOG.ENOG41099MV.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.026.AA.bctoNOG.ENOG41099MV.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.026.AA.bctoNOG.ENOG41099MV.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.026.AA.bctoNOG.ENOG41099MV.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.026.AA.bctoNOG.ENOG41099MV.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.026.AA.bctoNOG.ENOG41099MV.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.026.AA.bctoNOG.ENOG41099MV.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.026.AA.bctoNOG.ENOG41099MV.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.026.AA.bctoNOG.ENOG41099MV.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.026.AA.bctoNOG.ENOG41099MV.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.026.AA.bctoNOG.ENOG41099MV.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.026.AA.bctoNOG.ENOG41099MV.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.026.AA.bctoNOG.ENOG41099MV.fasta");

}

SCENARIO ("Alignment methods work correctly in example.027.AA.bctoNOG.ENOG41099NY.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.027.AA.bctoNOG.ENOG41099NY.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.027.AA.bctoNOG.ENOG41099NY.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.027.AA.bctoNOG.ENOG41099NY.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.027.AA.bctoNOG.ENOG41099NY.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.027.AA.bctoNOG.ENOG41099NY.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.027.AA.bctoNOG.ENOG41099NY.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.027.AA.bctoNOG.ENOG41099NY.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.027.AA.bctoNOG.ENOG41099NY.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.027.AA.bctoNOG.ENOG41099NY.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.027.AA.bctoNOG.ENOG41099NY.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.027.AA.bctoNOG.ENOG41099NY.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.027.AA.bctoNOG.ENOG41099NY.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.027.AA.bctoNOG.ENOG41099NY.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.027.AA.bctoNOG.ENOG41099NY.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.027.AA.bctoNOG.ENOG41099NY.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.027.AA.bctoNOG.ENOG41099NY.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.027.AA.bctoNOG.ENOG41099NY.fasta");

}

SCENARIO ("Alignment methods work correctly in example.028.AA.bctoNOG.ENOG41099PA.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.028.AA.bctoNOG.ENOG41099PA.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.028.AA.bctoNOG.ENOG41099PA.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.028.AA.bctoNOG.ENOG41099PA.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.028.AA.bctoNOG.ENOG41099PA.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.028.AA.bctoNOG.ENOG41099PA.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.028.AA.bctoNOG.ENOG41099PA.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.028.AA.bctoNOG.ENOG41099PA.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.028.AA.bctoNOG.ENOG41099PA.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.028.AA.bctoNOG.ENOG41099PA.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.028.AA.bctoNOG.ENOG41099PA.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.028.AA.bctoNOG.ENOG41099PA.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.028.AA.bctoNOG.ENOG41099PA.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.028.AA.bctoNOG.ENOG41099PA.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.028.AA.bctoNOG.ENOG41099PA.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.028.AA.bctoNOG.ENOG41099PA.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.028.AA.bctoNOG.ENOG41099PA.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.028.AA.bctoNOG.ENOG41099PA.fasta");

}

SCENARIO ("Alignment methods work correctly in example.029.AA.bctoNOG.ENOG41099Q3.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.029.AA.bctoNOG.ENOG41099Q3.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.029.AA.bctoNOG.ENOG41099Q3.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.029.AA.bctoNOG.ENOG41099Q3.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.029.AA.bctoNOG.ENOG41099Q3.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.029.AA.bctoNOG.ENOG41099Q3.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.029.AA.bctoNOG.ENOG41099Q3.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.029.AA.bctoNOG.ENOG41099Q3.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.029.AA.bctoNOG.ENOG41099Q3.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.029.AA.bctoNOG.ENOG41099Q3.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.029.AA.bctoNOG.ENOG41099Q3.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.029.AA.bctoNOG.ENOG41099Q3.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.029.AA.bctoNOG.ENOG41099Q3.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.029.AA.bctoNOG.ENOG41099Q3.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.029.AA.bctoNOG.ENOG41099Q3.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.029.AA.bctoNOG.ENOG41099Q3.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.029.AA.bctoNOG.ENOG41099Q3.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.029.AA.bctoNOG.ENOG41099Q3.fasta");

}

SCENARIO ("Alignment methods work correctly in example.030.AA.bctoNOG.ENOG41099RG.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.030.AA.bctoNOG.ENOG41099RG.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.030.AA.bctoNOG.ENOG41099RG.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.030.AA.bctoNOG.ENOG41099RG.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.030.AA.bctoNOG.ENOG41099RG.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.030.AA.bctoNOG.ENOG41099RG.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.030.AA.bctoNOG.ENOG41099RG.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.030.AA.bctoNOG.ENOG41099RG.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.030.AA.bctoNOG.ENOG41099RG.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.030.AA.bctoNOG.ENOG41099RG.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.030.AA.bctoNOG.ENOG41099RG.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.030.AA.bctoNOG.ENOG41099RG.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.030.AA.bctoNOG.ENOG41099RG.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.030.AA.bctoNOG.ENOG41099RG.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.030.AA.bctoNOG.ENOG41099RG.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.030.AA.bctoNOG.ENOG41099RG.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.030.AA.bctoNOG.ENOG41099RG.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.030.AA.bctoNOG.ENOG41099RG.fasta");

}

SCENARIO ("Alignment methods work correctly in example.031.AA.bctoNOG.ENOG41099UK.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.031.AA.bctoNOG.ENOG41099UK.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.031.AA.bctoNOG.ENOG41099UK.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.031.AA.bctoNOG.ENOG41099UK.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.031.AA.bctoNOG.ENOG41099UK.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.031.AA.bctoNOG.ENOG41099UK.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.031.AA.bctoNOG.ENOG41099UK.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.031.AA.bctoNOG.ENOG41099UK.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.031.AA.bctoNOG.ENOG41099UK.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.031.AA.bctoNOG.ENOG41099UK.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.031.AA.bctoNOG.ENOG41099UK.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.031.AA.bctoNOG.ENOG41099UK.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.031.AA.bctoNOG.ENOG41099UK.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.031.AA.bctoNOG.ENOG41099UK.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.031.AA.bctoNOG.ENOG41099UK.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.031.AA.bctoNOG.ENOG41099UK.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.031.AA.bctoNOG.ENOG41099UK.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.031.AA.bctoNOG.ENOG41099UK.fasta");

}

SCENARIO ("Alignment methods work correctly in example.032.AA.bctoNOG.ENOG41099UW.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.032.AA.bctoNOG.ENOG41099UW.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.032.AA.bctoNOG.ENOG41099UW.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.032.AA.bctoNOG.ENOG41099UW.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.032.AA.bctoNOG.ENOG41099UW.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.032.AA.bctoNOG.ENOG41099UW.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.032.AA.bctoNOG.ENOG41099UW.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.032.AA.bctoNOG.ENOG41099UW.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.032.AA.bctoNOG.ENOG41099UW.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.032.AA.bctoNOG.ENOG41099UW.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.032.AA.bctoNOG.ENOG41099UW.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.032.AA.bctoNOG.ENOG41099UW.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.032.AA.bctoNOG.ENOG41099UW.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.032.AA.bctoNOG.ENOG41099UW.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.032.AA.bctoNOG.ENOG41099UW.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.032.AA.bctoNOG.ENOG41099UW.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.032.AA.bctoNOG.ENOG41099UW.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.032.AA.bctoNOG.ENOG41099UW.fasta");

}

SCENARIO ("Alignment methods work correctly in example.033.AA.bctoNOG.ENOG41099VK.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.033.AA.bctoNOG.ENOG41099VK.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.033.AA.bctoNOG.ENOG41099VK.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.033.AA.bctoNOG.ENOG41099VK.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.033.AA.bctoNOG.ENOG41099VK.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.033.AA.bctoNOG.ENOG41099VK.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.033.AA.bctoNOG.ENOG41099VK.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.033.AA.bctoNOG.ENOG41099VK.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.033.AA.bctoNOG.ENOG41099VK.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.033.AA.bctoNOG.ENOG41099VK.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.033.AA.bctoNOG.ENOG41099VK.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.033.AA.bctoNOG.ENOG41099VK.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.033.AA.bctoNOG.ENOG41099VK.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.033.AA.bctoNOG.ENOG41099VK.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.033.AA.bctoNOG.ENOG41099VK.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.033.AA.bctoNOG.ENOG41099VK.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.033.AA.bctoNOG.ENOG41099VK.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.033.AA.bctoNOG.ENOG41099VK.fasta");

}

SCENARIO ("Alignment methods work correctly in example.034.AA.bctoNOG.ENOG41099WA.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.034.AA.bctoNOG.ENOG41099WA.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.034.AA.bctoNOG.ENOG41099WA.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.034.AA.bctoNOG.ENOG41099WA.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.034.AA.bctoNOG.ENOG41099WA.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.034.AA.bctoNOG.ENOG41099WA.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.034.AA.bctoNOG.ENOG41099WA.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.034.AA.bctoNOG.ENOG41099WA.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.034.AA.bctoNOG.ENOG41099WA.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.034.AA.bctoNOG.ENOG41099WA.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.034.AA.bctoNOG.ENOG41099WA.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.034.AA.bctoNOG.ENOG41099WA.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.034.AA.bctoNOG.ENOG41099WA.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.034.AA.bctoNOG.ENOG41099WA.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.034.AA.bctoNOG.ENOG41099WA.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.034.AA.bctoNOG.ENOG41099WA.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.034.AA.bctoNOG.ENOG41099WA.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.034.AA.bctoNOG.ENOG41099WA.fasta");

}

SCENARIO ("Alignment methods work correctly in example.035.AA.bctoNOG.ENOG41099WF.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.035.AA.bctoNOG.ENOG41099WF.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.035.AA.bctoNOG.ENOG41099WF.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.035.AA.bctoNOG.ENOG41099WF.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.035.AA.bctoNOG.ENOG41099WF.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.035.AA.bctoNOG.ENOG41099WF.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.035.AA.bctoNOG.ENOG41099WF.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.035.AA.bctoNOG.ENOG41099WF.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.035.AA.bctoNOG.ENOG41099WF.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.035.AA.bctoNOG.ENOG41099WF.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.035.AA.bctoNOG.ENOG41099WF.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.035.AA.bctoNOG.ENOG41099WF.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.035.AA.bctoNOG.ENOG41099WF.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.035.AA.bctoNOG.ENOG41099WF.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.035.AA.bctoNOG.ENOG41099WF.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.035.AA.bctoNOG.ENOG41099WF.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.035.AA.bctoNOG.ENOG41099WF.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.035.AA.bctoNOG.ENOG41099WF.fasta");

}

SCENARIO ("Alignment methods work correctly in example.036.AA.bctoNOG.ENOG41099XJ.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.036.AA.bctoNOG.ENOG41099XJ.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.036.AA.bctoNOG.ENOG41099XJ.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.036.AA.bctoNOG.ENOG41099XJ.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.036.AA.bctoNOG.ENOG41099XJ.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.036.AA.bctoNOG.ENOG41099XJ.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.036.AA.bctoNOG.ENOG41099XJ.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.036.AA.bctoNOG.ENOG41099XJ.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.036.AA.bctoNOG.ENOG41099XJ.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.036.AA.bctoNOG.ENOG41099XJ.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.036.AA.bctoNOG.ENOG41099XJ.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.036.AA.bctoNOG.ENOG41099XJ.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.036.AA.bctoNOG.ENOG41099XJ.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.036.AA.bctoNOG.ENOG41099XJ.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.036.AA.bctoNOG.ENOG41099XJ.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.036.AA.bctoNOG.ENOG41099XJ.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.036.AA.bctoNOG.ENOG41099XJ.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.036.AA.bctoNOG.ENOG41099XJ.fasta");

}

SCENARIO ("Alignment methods work correctly in example.037.AA.bctoNOG.ENOG41099XP.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.037.AA.bctoNOG.ENOG41099XP.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.037.AA.bctoNOG.ENOG41099XP.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.037.AA.bctoNOG.ENOG41099XP.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.037.AA.bctoNOG.ENOG41099XP.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.037.AA.bctoNOG.ENOG41099XP.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.037.AA.bctoNOG.ENOG41099XP.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.037.AA.bctoNOG.ENOG41099XP.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.037.AA.bctoNOG.ENOG41099XP.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.037.AA.bctoNOG.ENOG41099XP.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.037.AA.bctoNOG.ENOG41099XP.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.037.AA.bctoNOG.ENOG41099XP.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.037.AA.bctoNOG.ENOG41099XP.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.037.AA.bctoNOG.ENOG41099XP.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.037.AA.bctoNOG.ENOG41099XP.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.037.AA.bctoNOG.ENOG41099XP.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.037.AA.bctoNOG.ENOG41099XP.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.037.AA.bctoNOG.ENOG41099XP.fasta");

}

SCENARIO ("Alignment methods work correctly in example.038.AA.bctoNOG.ENOG41099Y4.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.038.AA.bctoNOG.ENOG41099Y4.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.038.AA.bctoNOG.ENOG41099Y4.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.038.AA.bctoNOG.ENOG41099Y4.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.038.AA.bctoNOG.ENOG41099Y4.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.038.AA.bctoNOG.ENOG41099Y4.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.038.AA.bctoNOG.ENOG41099Y4.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.038.AA.bctoNOG.ENOG41099Y4.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.038.AA.bctoNOG.ENOG41099Y4.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.038.AA.bctoNOG.ENOG41099Y4.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.038.AA.bctoNOG.ENOG41099Y4.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.038.AA.bctoNOG.ENOG41099Y4.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.038.AA.bctoNOG.ENOG41099Y4.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.038.AA.bctoNOG.ENOG41099Y4.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.038.AA.bctoNOG.ENOG41099Y4.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.038.AA.bctoNOG.ENOG41099Y4.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.038.AA.bctoNOG.ENOG41099Y4.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.038.AA.bctoNOG.ENOG41099Y4.fasta");

}

SCENARIO ("Alignment methods work correctly in example.039.AA.bctoNOG.ENOG41099YD.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.039.AA.bctoNOG.ENOG41099YD.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.039.AA.bctoNOG.ENOG41099YD.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.039.AA.bctoNOG.ENOG41099YD.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.039.AA.bctoNOG.ENOG41099YD.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.039.AA.bctoNOG.ENOG41099YD.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.039.AA.bctoNOG.ENOG41099YD.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.039.AA.bctoNOG.ENOG41099YD.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.039.AA.bctoNOG.ENOG41099YD.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.039.AA.bctoNOG.ENOG41099YD.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.039.AA.bctoNOG.ENOG41099YD.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.039.AA.bctoNOG.ENOG41099YD.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.039.AA.bctoNOG.ENOG41099YD.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.039.AA.bctoNOG.ENOG41099YD.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.039.AA.bctoNOG.ENOG41099YD.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.039.AA.bctoNOG.ENOG41099YD.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.039.AA.bctoNOG.ENOG41099YD.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.039.AA.bctoNOG.ENOG41099YD.fasta");

}

SCENARIO ("Alignment methods work correctly in example.040.AA.bctoNOG.ENOG4109A32.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.040.AA.bctoNOG.ENOG4109A32.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.040.AA.bctoNOG.ENOG4109A32.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.040.AA.bctoNOG.ENOG4109A32.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.040.AA.bctoNOG.ENOG4109A32.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.040.AA.bctoNOG.ENOG4109A32.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.040.AA.bctoNOG.ENOG4109A32.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.040.AA.bctoNOG.ENOG4109A32.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.040.AA.bctoNOG.ENOG4109A32.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.040.AA.bctoNOG.ENOG4109A32.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.040.AA.bctoNOG.ENOG4109A32.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.040.AA.bctoNOG.ENOG4109A32.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.040.AA.bctoNOG.ENOG4109A32.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.040.AA.bctoNOG.ENOG4109A32.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.040.AA.bctoNOG.ENOG4109A32.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.040.AA.bctoNOG.ENOG4109A32.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.040.AA.bctoNOG.ENOG4109A32.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.040.AA.bctoNOG.ENOG4109A32.fasta");

}

SCENARIO ("Alignment methods work correctly in example.041.AA.bctoNOG.ENOG4109A5T.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.041.AA.bctoNOG.ENOG4109A5T.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.041.AA.bctoNOG.ENOG4109A5T.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.041.AA.bctoNOG.ENOG4109A5T.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.041.AA.bctoNOG.ENOG4109A5T.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.041.AA.bctoNOG.ENOG4109A5T.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.041.AA.bctoNOG.ENOG4109A5T.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.041.AA.bctoNOG.ENOG4109A5T.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.041.AA.bctoNOG.ENOG4109A5T.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.041.AA.bctoNOG.ENOG4109A5T.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.041.AA.bctoNOG.ENOG4109A5T.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.041.AA.bctoNOG.ENOG4109A5T.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.041.AA.bctoNOG.ENOG4109A5T.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.041.AA.bctoNOG.ENOG4109A5T.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.041.AA.bctoNOG.ENOG4109A5T.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.041.AA.bctoNOG.ENOG4109A5T.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.041.AA.bctoNOG.ENOG4109A5T.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.041.AA.bctoNOG.ENOG4109A5T.fasta");

}

SCENARIO ("Alignment methods work correctly in example.042.AA.bctoNOG.ENOG4109A9M.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.042.AA.bctoNOG.ENOG4109A9M.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.042.AA.bctoNOG.ENOG4109A9M.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.042.AA.bctoNOG.ENOG4109A9M.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.042.AA.bctoNOG.ENOG4109A9M.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.042.AA.bctoNOG.ENOG4109A9M.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.042.AA.bctoNOG.ENOG4109A9M.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.042.AA.bctoNOG.ENOG4109A9M.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.042.AA.bctoNOG.ENOG4109A9M.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.042.AA.bctoNOG.ENOG4109A9M.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.042.AA.bctoNOG.ENOG4109A9M.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.042.AA.bctoNOG.ENOG4109A9M.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.042.AA.bctoNOG.ENOG4109A9M.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.042.AA.bctoNOG.ENOG4109A9M.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.042.AA.bctoNOG.ENOG4109A9M.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.042.AA.bctoNOG.ENOG4109A9M.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.042.AA.bctoNOG.ENOG4109A9M.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.042.AA.bctoNOG.ENOG4109A9M.fasta");

}

SCENARIO ("Alignment methods work correctly in example.043.AA.bctoNOG.ENOG4109ADN.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.043.AA.bctoNOG.ENOG4109ADN.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.043.AA.bctoNOG.ENOG4109ADN.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.043.AA.bctoNOG.ENOG4109ADN.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.043.AA.bctoNOG.ENOG4109ADN.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.043.AA.bctoNOG.ENOG4109ADN.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.043.AA.bctoNOG.ENOG4109ADN.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.043.AA.bctoNOG.ENOG4109ADN.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.043.AA.bctoNOG.ENOG4109ADN.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.043.AA.bctoNOG.ENOG4109ADN.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.043.AA.bctoNOG.ENOG4109ADN.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.043.AA.bctoNOG.ENOG4109ADN.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.043.AA.bctoNOG.ENOG4109ADN.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.043.AA.bctoNOG.ENOG4109ADN.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.043.AA.bctoNOG.ENOG4109ADN.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.043.AA.bctoNOG.ENOG4109ADN.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.043.AA.bctoNOG.ENOG4109ADN.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.043.AA.bctoNOG.ENOG4109ADN.fasta");

}

SCENARIO ("Alignment methods work correctly in example.044.AA.bctoNOG.ENOG4109AED.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.044.AA.bctoNOG.ENOG4109AED.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.044.AA.bctoNOG.ENOG4109AED.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.044.AA.bctoNOG.ENOG4109AED.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.044.AA.bctoNOG.ENOG4109AED.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.044.AA.bctoNOG.ENOG4109AED.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.044.AA.bctoNOG.ENOG4109AED.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.044.AA.bctoNOG.ENOG4109AED.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.044.AA.bctoNOG.ENOG4109AED.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.044.AA.bctoNOG.ENOG4109AED.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.044.AA.bctoNOG.ENOG4109AED.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.044.AA.bctoNOG.ENOG4109AED.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.044.AA.bctoNOG.ENOG4109AED.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.044.AA.bctoNOG.ENOG4109AED.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.044.AA.bctoNOG.ENOG4109AED.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.044.AA.bctoNOG.ENOG4109AED.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.044.AA.bctoNOG.ENOG4109AED.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.044.AA.bctoNOG.ENOG4109AED.fasta");

}

SCENARIO ("Alignment methods work correctly in example.045.AA.bctoNOG.ENOG4109AGT.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.045.AA.bctoNOG.ENOG4109AGT.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.045.AA.bctoNOG.ENOG4109AGT.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.045.AA.bctoNOG.ENOG4109AGT.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.045.AA.bctoNOG.ENOG4109AGT.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.045.AA.bctoNOG.ENOG4109AGT.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.045.AA.bctoNOG.ENOG4109AGT.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.045.AA.bctoNOG.ENOG4109AGT.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.045.AA.bctoNOG.ENOG4109AGT.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.045.AA.bctoNOG.ENOG4109AGT.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.045.AA.bctoNOG.ENOG4109AGT.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.045.AA.bctoNOG.ENOG4109AGT.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.045.AA.bctoNOG.ENOG4109AGT.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.045.AA.bctoNOG.ENOG4109AGT.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.045.AA.bctoNOG.ENOG4109AGT.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.045.AA.bctoNOG.ENOG4109AGT.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.045.AA.bctoNOG.ENOG4109AGT.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.045.AA.bctoNOG.ENOG4109AGT.fasta");

}

SCENARIO ("Alignment methods work correctly in example.046.AA.bctoNOG.ENOG4109AGW.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.046.AA.bctoNOG.ENOG4109AGW.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.046.AA.bctoNOG.ENOG4109AGW.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.046.AA.bctoNOG.ENOG4109AGW.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.046.AA.bctoNOG.ENOG4109AGW.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.046.AA.bctoNOG.ENOG4109AGW.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.046.AA.bctoNOG.ENOG4109AGW.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.046.AA.bctoNOG.ENOG4109AGW.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.046.AA.bctoNOG.ENOG4109AGW.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.046.AA.bctoNOG.ENOG4109AGW.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.046.AA.bctoNOG.ENOG4109AGW.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.046.AA.bctoNOG.ENOG4109AGW.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.046.AA.bctoNOG.ENOG4109AGW.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.046.AA.bctoNOG.ENOG4109AGW.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.046.AA.bctoNOG.ENOG4109AGW.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.046.AA.bctoNOG.ENOG4109AGW.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.046.AA.bctoNOG.ENOG4109AGW.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.046.AA.bctoNOG.ENOG4109AGW.fasta");

}

SCENARIO ("Alignment methods work correctly in example.047.AA.bctoNOG.ENOG4109AIC.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.047.AA.bctoNOG.ENOG4109AIC.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.047.AA.bctoNOG.ENOG4109AIC.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.047.AA.bctoNOG.ENOG4109AIC.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.047.AA.bctoNOG.ENOG4109AIC.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.047.AA.bctoNOG.ENOG4109AIC.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.047.AA.bctoNOG.ENOG4109AIC.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.047.AA.bctoNOG.ENOG4109AIC.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.047.AA.bctoNOG.ENOG4109AIC.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.047.AA.bctoNOG.ENOG4109AIC.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.047.AA.bctoNOG.ENOG4109AIC.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.047.AA.bctoNOG.ENOG4109AIC.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.047.AA.bctoNOG.ENOG4109AIC.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.047.AA.bctoNOG.ENOG4109AIC.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.047.AA.bctoNOG.ENOG4109AIC.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.047.AA.bctoNOG.ENOG4109AIC.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.047.AA.bctoNOG.ENOG4109AIC.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.047.AA.bctoNOG.ENOG4109AIC.fasta");

}

SCENARIO ("Alignment methods work correctly in example.048.AA.bctoNOG.ENOG4109AJ3.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.048.AA.bctoNOG.ENOG4109AJ3.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.048.AA.bctoNOG.ENOG4109AJ3.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.048.AA.bctoNOG.ENOG4109AJ3.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.048.AA.bctoNOG.ENOG4109AJ3.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.048.AA.bctoNOG.ENOG4109AJ3.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.048.AA.bctoNOG.ENOG4109AJ3.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.048.AA.bctoNOG.ENOG4109AJ3.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.048.AA.bctoNOG.ENOG4109AJ3.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.048.AA.bctoNOG.ENOG4109AJ3.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.048.AA.bctoNOG.ENOG4109AJ3.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.048.AA.bctoNOG.ENOG4109AJ3.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.048.AA.bctoNOG.ENOG4109AJ3.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.048.AA.bctoNOG.ENOG4109AJ3.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.048.AA.bctoNOG.ENOG4109AJ3.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.048.AA.bctoNOG.ENOG4109AJ3.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.048.AA.bctoNOG.ENOG4109AJ3.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.048.AA.bctoNOG.ENOG4109AJ3.fasta");

}

SCENARIO ("Alignment methods work correctly in example.049.AA.bctoNOG.ENOG4109AY5.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.049.AA.bctoNOG.ENOG4109AY5.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.049.AA.bctoNOG.ENOG4109AY5.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.049.AA.bctoNOG.ENOG4109AY5.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.049.AA.bctoNOG.ENOG4109AY5.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.049.AA.bctoNOG.ENOG4109AY5.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.049.AA.bctoNOG.ENOG4109AY5.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.049.AA.bctoNOG.ENOG4109AY5.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.049.AA.bctoNOG.ENOG4109AY5.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.049.AA.bctoNOG.ENOG4109AY5.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.049.AA.bctoNOG.ENOG4109AY5.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.049.AA.bctoNOG.ENOG4109AY5.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.049.AA.bctoNOG.ENOG4109AY5.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.049.AA.bctoNOG.ENOG4109AY5.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.049.AA.bctoNOG.ENOG4109AY5.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.049.AA.bctoNOG.ENOG4109AY5.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.049.AA.bctoNOG.ENOG4109AY5.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.049.AA.bctoNOG.ENOG4109AY5.fasta");

}

SCENARIO ("Alignment methods work correctly in example.050.AA.bctoNOG.ENOG4109B8Z.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.050.AA.bctoNOG.ENOG4109B8Z.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.050.AA.bctoNOG.ENOG4109B8Z.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.050.AA.bctoNOG.ENOG4109B8Z.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.050.AA.bctoNOG.ENOG4109B8Z.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.050.AA.bctoNOG.ENOG4109B8Z.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.050.AA.bctoNOG.ENOG4109B8Z.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.050.AA.bctoNOG.ENOG4109B8Z.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.050.AA.bctoNOG.ENOG4109B8Z.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.050.AA.bctoNOG.ENOG4109B8Z.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.050.AA.bctoNOG.ENOG4109B8Z.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.050.AA.bctoNOG.ENOG4109B8Z.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.050.AA.bctoNOG.ENOG4109B8Z.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.050.AA.bctoNOG.ENOG4109B8Z.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.050.AA.bctoNOG.ENOG4109B8Z.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.050.AA.bctoNOG.ENOG4109B8Z.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.050.AA.bctoNOG.ENOG4109B8Z.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.050.AA.bctoNOG.ENOG4109B8Z.fasta");

}

SCENARIO ("Alignment methods work correctly in example.051.AA.bctoNOG.ENOG4109BCJ.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.051.AA.bctoNOG.ENOG4109BCJ.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.051.AA.bctoNOG.ENOG4109BCJ.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.051.AA.bctoNOG.ENOG4109BCJ.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.051.AA.bctoNOG.ENOG4109BCJ.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.051.AA.bctoNOG.ENOG4109BCJ.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.051.AA.bctoNOG.ENOG4109BCJ.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.051.AA.bctoNOG.ENOG4109BCJ.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.051.AA.bctoNOG.ENOG4109BCJ.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.051.AA.bctoNOG.ENOG4109BCJ.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.051.AA.bctoNOG.ENOG4109BCJ.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.051.AA.bctoNOG.ENOG4109BCJ.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.051.AA.bctoNOG.ENOG4109BCJ.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.051.AA.bctoNOG.ENOG4109BCJ.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.051.AA.bctoNOG.ENOG4109BCJ.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.051.AA.bctoNOG.ENOG4109BCJ.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.051.AA.bctoNOG.ENOG4109BCJ.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.051.AA.bctoNOG.ENOG4109BCJ.fasta");

}

SCENARIO ("Alignment methods work correctly in example.052.AA.bctoNOG.ENOG4109CTU.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.052.AA.bctoNOG.ENOG4109CTU.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.052.AA.bctoNOG.ENOG4109CTU.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.052.AA.bctoNOG.ENOG4109CTU.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.052.AA.bctoNOG.ENOG4109CTU.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.052.AA.bctoNOG.ENOG4109CTU.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.052.AA.bctoNOG.ENOG4109CTU.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.052.AA.bctoNOG.ENOG4109CTU.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.052.AA.bctoNOG.ENOG4109CTU.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.052.AA.bctoNOG.ENOG4109CTU.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.052.AA.bctoNOG.ENOG4109CTU.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.052.AA.bctoNOG.ENOG4109CTU.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.052.AA.bctoNOG.ENOG4109CTU.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.052.AA.bctoNOG.ENOG4109CTU.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.052.AA.bctoNOG.ENOG4109CTU.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.052.AA.bctoNOG.ENOG4109CTU.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.052.AA.bctoNOG.ENOG4109CTU.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.052.AA.bctoNOG.ENOG4109CTU.fasta");

}

SCENARIO ("Alignment methods work correctly in example.053.AA.bctoNOG.ENOG4109CVC.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.053.AA.bctoNOG.ENOG4109CVC.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.053.AA.bctoNOG.ENOG4109CVC.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.053.AA.bctoNOG.ENOG4109CVC.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.053.AA.bctoNOG.ENOG4109CVC.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.053.AA.bctoNOG.ENOG4109CVC.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.053.AA.bctoNOG.ENOG4109CVC.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.053.AA.bctoNOG.ENOG4109CVC.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.053.AA.bctoNOG.ENOG4109CVC.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.053.AA.bctoNOG.ENOG4109CVC.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.053.AA.bctoNOG.ENOG4109CVC.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.053.AA.bctoNOG.ENOG4109CVC.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.053.AA.bctoNOG.ENOG4109CVC.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.053.AA.bctoNOG.ENOG4109CVC.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.053.AA.bctoNOG.ENOG4109CVC.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.053.AA.bctoNOG.ENOG4109CVC.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.053.AA.bctoNOG.ENOG4109CVC.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.053.AA.bctoNOG.ENOG4109CVC.fasta");

}

SCENARIO ("Alignment methods work correctly in example.054.AA.bctoNOG.ENOG4109FIT.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.054.AA.bctoNOG.ENOG4109FIT.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.054.AA.bctoNOG.ENOG4109FIT.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.054.AA.bctoNOG.ENOG4109FIT.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.054.AA.bctoNOG.ENOG4109FIT.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.054.AA.bctoNOG.ENOG4109FIT.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.054.AA.bctoNOG.ENOG4109FIT.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.054.AA.bctoNOG.ENOG4109FIT.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.054.AA.bctoNOG.ENOG4109FIT.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.054.AA.bctoNOG.ENOG4109FIT.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.054.AA.bctoNOG.ENOG4109FIT.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.054.AA.bctoNOG.ENOG4109FIT.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.054.AA.bctoNOG.ENOG4109FIT.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.054.AA.bctoNOG.ENOG4109FIT.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.054.AA.bctoNOG.ENOG4109FIT.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.054.AA.bctoNOG.ENOG4109FIT.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.054.AA.bctoNOG.ENOG4109FIT.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.054.AA.bctoNOG.ENOG4109FIT.fasta");

}

SCENARIO ("Alignment methods work correctly in example.055.AA.bctoNOG.ENOG4109GY9.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.055.AA.bctoNOG.ENOG4109GY9.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.055.AA.bctoNOG.ENOG4109GY9.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.055.AA.bctoNOG.ENOG4109GY9.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.055.AA.bctoNOG.ENOG4109GY9.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.055.AA.bctoNOG.ENOG4109GY9.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.055.AA.bctoNOG.ENOG4109GY9.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.055.AA.bctoNOG.ENOG4109GY9.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.055.AA.bctoNOG.ENOG4109GY9.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.055.AA.bctoNOG.ENOG4109GY9.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.055.AA.bctoNOG.ENOG4109GY9.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.055.AA.bctoNOG.ENOG4109GY9.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.055.AA.bctoNOG.ENOG4109GY9.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.055.AA.bctoNOG.ENOG4109GY9.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.055.AA.bctoNOG.ENOG4109GY9.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.055.AA.bctoNOG.ENOG4109GY9.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.055.AA.bctoNOG.ENOG4109GY9.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.055.AA.bctoNOG.ENOG4109GY9.fasta");

}

SCENARIO ("Alignment methods work correctly in example.056.AA.bctoNOG.ENOG4109IPJ.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.056.AA.bctoNOG.ENOG4109IPJ.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.056.AA.bctoNOG.ENOG4109IPJ.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.056.AA.bctoNOG.ENOG4109IPJ.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.056.AA.bctoNOG.ENOG4109IPJ.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.056.AA.bctoNOG.ENOG4109IPJ.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.056.AA.bctoNOG.ENOG4109IPJ.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.056.AA.bctoNOG.ENOG4109IPJ.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.056.AA.bctoNOG.ENOG4109IPJ.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.056.AA.bctoNOG.ENOG4109IPJ.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.056.AA.bctoNOG.ENOG4109IPJ.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.056.AA.bctoNOG.ENOG4109IPJ.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.056.AA.bctoNOG.ENOG4109IPJ.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.056.AA.bctoNOG.ENOG4109IPJ.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.056.AA.bctoNOG.ENOG4109IPJ.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.056.AA.bctoNOG.ENOG4109IPJ.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.056.AA.bctoNOG.ENOG4109IPJ.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.056.AA.bctoNOG.ENOG4109IPJ.fasta");

}

SCENARIO ("Alignment methods work correctly in example.057.AA.bctoNOG.ENOG4109SZ2.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.057.AA.bctoNOG.ENOG4109SZ2.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.057.AA.bctoNOG.ENOG4109SZ2.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.057.AA.bctoNOG.ENOG4109SZ2.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.057.AA.bctoNOG.ENOG4109SZ2.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.057.AA.bctoNOG.ENOG4109SZ2.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.057.AA.bctoNOG.ENOG4109SZ2.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.057.AA.bctoNOG.ENOG4109SZ2.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.057.AA.bctoNOG.ENOG4109SZ2.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.057.AA.bctoNOG.ENOG4109SZ2.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.057.AA.bctoNOG.ENOG4109SZ2.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.057.AA.bctoNOG.ENOG4109SZ2.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.057.AA.bctoNOG.ENOG4109SZ2.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.057.AA.bctoNOG.ENOG4109SZ2.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.057.AA.bctoNOG.ENOG4109SZ2.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.057.AA.bctoNOG.ENOG4109SZ2.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.057.AA.bctoNOG.ENOG4109SZ2.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.057.AA.bctoNOG.ENOG4109SZ2.fasta");

}

SCENARIO ("Alignment methods work correctly in example.058.AA.strNOG.ENOG411BBR6.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.058.AA.strNOG.ENOG411BBR6.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.058.AA.strNOG.ENOG411BBR6.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.058.AA.strNOG.ENOG411BBR6.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.058.AA.strNOG.ENOG411BBR6.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.058.AA.strNOG.ENOG411BBR6.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.058.AA.strNOG.ENOG411BBR6.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.058.AA.strNOG.ENOG411BBR6.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.058.AA.strNOG.ENOG411BBR6.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.058.AA.strNOG.ENOG411BBR6.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.058.AA.strNOG.ENOG411BBR6.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.058.AA.strNOG.ENOG411BBR6.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.058.AA.strNOG.ENOG411BBR6.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.058.AA.strNOG.ENOG411BBR6.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.058.AA.strNOG.ENOG411BBR6.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.058.AA.strNOG.ENOG411BBR6.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.058.AA.strNOG.ENOG411BBR6.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.058.AA.strNOG.ENOG411BBR6.fasta");

}

SCENARIO ("Alignment methods work correctly in example.059.AA.strNOG.ENOG411BBRR.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.059.AA.strNOG.ENOG411BBRR.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.059.AA.strNOG.ENOG411BBRR.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.059.AA.strNOG.ENOG411BBRR.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.059.AA.strNOG.ENOG411BBRR.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.059.AA.strNOG.ENOG411BBRR.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.059.AA.strNOG.ENOG411BBRR.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.059.AA.strNOG.ENOG411BBRR.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.059.AA.strNOG.ENOG411BBRR.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.059.AA.strNOG.ENOG411BBRR.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.059.AA.strNOG.ENOG411BBRR.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.059.AA.strNOG.ENOG411BBRR.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.059.AA.strNOG.ENOG411BBRR.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.059.AA.strNOG.ENOG411BBRR.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.059.AA.strNOG.ENOG411BBRR.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.059.AA.strNOG.ENOG411BBRR.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.059.AA.strNOG.ENOG411BBRR.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.059.AA.strNOG.ENOG411BBRR.fasta");

}

SCENARIO ("Alignment methods work correctly in example.060.AA.strNOG.ENOG411BBWK.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.060.AA.strNOG.ENOG411BBWK.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.060.AA.strNOG.ENOG411BBWK.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.060.AA.strNOG.ENOG411BBWK.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.060.AA.strNOG.ENOG411BBWK.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.060.AA.strNOG.ENOG411BBWK.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.060.AA.strNOG.ENOG411BBWK.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.060.AA.strNOG.ENOG411BBWK.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.060.AA.strNOG.ENOG411BBWK.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.060.AA.strNOG.ENOG411BBWK.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.060.AA.strNOG.ENOG411BBWK.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.060.AA.strNOG.ENOG411BBWK.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.060.AA.strNOG.ENOG411BBWK.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.060.AA.strNOG.ENOG411BBWK.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.060.AA.strNOG.ENOG411BBWK.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.060.AA.strNOG.ENOG411BBWK.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.060.AA.strNOG.ENOG411BBWK.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.060.AA.strNOG.ENOG411BBWK.fasta");

}

SCENARIO ("Alignment methods work correctly in example.061.AA.strNOG.ENOG411BCDZ.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.061.AA.strNOG.ENOG411BCDZ.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.061.AA.strNOG.ENOG411BCDZ.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.061.AA.strNOG.ENOG411BCDZ.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.061.AA.strNOG.ENOG411BCDZ.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.061.AA.strNOG.ENOG411BCDZ.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.061.AA.strNOG.ENOG411BCDZ.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.061.AA.strNOG.ENOG411BCDZ.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.061.AA.strNOG.ENOG411BCDZ.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.061.AA.strNOG.ENOG411BCDZ.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.061.AA.strNOG.ENOG411BCDZ.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.061.AA.strNOG.ENOG411BCDZ.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.061.AA.strNOG.ENOG411BCDZ.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.061.AA.strNOG.ENOG411BCDZ.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.061.AA.strNOG.ENOG411BCDZ.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.061.AA.strNOG.ENOG411BCDZ.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.061.AA.strNOG.ENOG411BCDZ.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.061.AA.strNOG.ENOG411BCDZ.fasta");

}

SCENARIO ("Alignment methods work correctly in example.062.AA.strNOG.ENOG411BCX3.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.062.AA.strNOG.ENOG411BCX3.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.062.AA.strNOG.ENOG411BCX3.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.062.AA.strNOG.ENOG411BCX3.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.062.AA.strNOG.ENOG411BCX3.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.062.AA.strNOG.ENOG411BCX3.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.062.AA.strNOG.ENOG411BCX3.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.062.AA.strNOG.ENOG411BCX3.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.062.AA.strNOG.ENOG411BCX3.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.062.AA.strNOG.ENOG411BCX3.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.062.AA.strNOG.ENOG411BCX3.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.062.AA.strNOG.ENOG411BCX3.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.062.AA.strNOG.ENOG411BCX3.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.062.AA.strNOG.ENOG411BCX3.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.062.AA.strNOG.ENOG411BCX3.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.062.AA.strNOG.ENOG411BCX3.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.062.AA.strNOG.ENOG411BCX3.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.062.AA.strNOG.ENOG411BCX3.fasta");

}

SCENARIO ("Alignment methods work correctly in example.063.AA.strNOG.ENOG411BDBU.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.063.AA.strNOG.ENOG411BDBU.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.063.AA.strNOG.ENOG411BDBU.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.063.AA.strNOG.ENOG411BDBU.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.063.AA.strNOG.ENOG411BDBU.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.063.AA.strNOG.ENOG411BDBU.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.063.AA.strNOG.ENOG411BDBU.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.063.AA.strNOG.ENOG411BDBU.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.063.AA.strNOG.ENOG411BDBU.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.063.AA.strNOG.ENOG411BDBU.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.063.AA.strNOG.ENOG411BDBU.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.063.AA.strNOG.ENOG411BDBU.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.063.AA.strNOG.ENOG411BDBU.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.063.AA.strNOG.ENOG411BDBU.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.063.AA.strNOG.ENOG411BDBU.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.063.AA.strNOG.ENOG411BDBU.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.063.AA.strNOG.ENOG411BDBU.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.063.AA.strNOG.ENOG411BDBU.fasta");

}

SCENARIO ("Alignment methods work correctly in example.064.AA.strNOG.ENOG411BDKC.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.064.AA.strNOG.ENOG411BDKC.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.064.AA.strNOG.ENOG411BDKC.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.064.AA.strNOG.ENOG411BDKC.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.064.AA.strNOG.ENOG411BDKC.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.064.AA.strNOG.ENOG411BDKC.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.064.AA.strNOG.ENOG411BDKC.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.064.AA.strNOG.ENOG411BDKC.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.064.AA.strNOG.ENOG411BDKC.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.064.AA.strNOG.ENOG411BDKC.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.064.AA.strNOG.ENOG411BDKC.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.064.AA.strNOG.ENOG411BDKC.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.064.AA.strNOG.ENOG411BDKC.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.064.AA.strNOG.ENOG411BDKC.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.064.AA.strNOG.ENOG411BDKC.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.064.AA.strNOG.ENOG411BDKC.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.064.AA.strNOG.ENOG411BDKC.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.064.AA.strNOG.ENOG411BDKC.fasta");

}

SCENARIO ("Alignment methods work correctly in example.065.AA.strNOG.ENOG411BDSZ.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.065.AA.strNOG.ENOG411BDSZ.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.065.AA.strNOG.ENOG411BDSZ.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.065.AA.strNOG.ENOG411BDSZ.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.065.AA.strNOG.ENOG411BDSZ.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.065.AA.strNOG.ENOG411BDSZ.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.065.AA.strNOG.ENOG411BDSZ.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.065.AA.strNOG.ENOG411BDSZ.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.065.AA.strNOG.ENOG411BDSZ.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.065.AA.strNOG.ENOG411BDSZ.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.065.AA.strNOG.ENOG411BDSZ.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.065.AA.strNOG.ENOG411BDSZ.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.065.AA.strNOG.ENOG411BDSZ.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.065.AA.strNOG.ENOG411BDSZ.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.065.AA.strNOG.ENOG411BDSZ.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.065.AA.strNOG.ENOG411BDSZ.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.065.AA.strNOG.ENOG411BDSZ.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.065.AA.strNOG.ENOG411BDSZ.fasta");

}

SCENARIO ("Alignment methods work correctly in example.066.AA.strNOG.ENOG411BDUE.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.066.AA.strNOG.ENOG411BDUE.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.066.AA.strNOG.ENOG411BDUE.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.066.AA.strNOG.ENOG411BDUE.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.066.AA.strNOG.ENOG411BDUE.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.066.AA.strNOG.ENOG411BDUE.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.066.AA.strNOG.ENOG411BDUE.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.066.AA.strNOG.ENOG411BDUE.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.066.AA.strNOG.ENOG411BDUE.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.066.AA.strNOG.ENOG411BDUE.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.066.AA.strNOG.ENOG411BDUE.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.066.AA.strNOG.ENOG411BDUE.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.066.AA.strNOG.ENOG411BDUE.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.066.AA.strNOG.ENOG411BDUE.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.066.AA.strNOG.ENOG411BDUE.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.066.AA.strNOG.ENOG411BDUE.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.066.AA.strNOG.ENOG411BDUE.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.066.AA.strNOG.ENOG411BDUE.fasta");

}

SCENARIO ("Alignment methods work correctly in example.067.AA.strNOG.ENOG411BDX3.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.067.AA.strNOG.ENOG411BDX3.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.067.AA.strNOG.ENOG411BDX3.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.067.AA.strNOG.ENOG411BDX3.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.067.AA.strNOG.ENOG411BDX3.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.067.AA.strNOG.ENOG411BDX3.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.067.AA.strNOG.ENOG411BDX3.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.067.AA.strNOG.ENOG411BDX3.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.067.AA.strNOG.ENOG411BDX3.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.067.AA.strNOG.ENOG411BDX3.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.067.AA.strNOG.ENOG411BDX3.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.067.AA.strNOG.ENOG411BDX3.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.067.AA.strNOG.ENOG411BDX3.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.067.AA.strNOG.ENOG411BDX3.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.067.AA.strNOG.ENOG411BDX3.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.067.AA.strNOG.ENOG411BDX3.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.067.AA.strNOG.ENOG411BDX3.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.067.AA.strNOG.ENOG411BDX3.fasta");

}

SCENARIO ("Alignment methods work correctly in example.068.AA.strNOG.ENOG411BE45.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.068.AA.strNOG.ENOG411BE45.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.068.AA.strNOG.ENOG411BE45.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.068.AA.strNOG.ENOG411BE45.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.068.AA.strNOG.ENOG411BE45.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.068.AA.strNOG.ENOG411BE45.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.068.AA.strNOG.ENOG411BE45.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.068.AA.strNOG.ENOG411BE45.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.068.AA.strNOG.ENOG411BE45.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.068.AA.strNOG.ENOG411BE45.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.068.AA.strNOG.ENOG411BE45.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.068.AA.strNOG.ENOG411BE45.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.068.AA.strNOG.ENOG411BE45.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.068.AA.strNOG.ENOG411BE45.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.068.AA.strNOG.ENOG411BE45.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.068.AA.strNOG.ENOG411BE45.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.068.AA.strNOG.ENOG411BE45.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.068.AA.strNOG.ENOG411BE45.fasta");

}

SCENARIO ("Alignment methods work correctly in example.069.AA.strNOG.ENOG411BE8B.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.069.AA.strNOG.ENOG411BE8B.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.069.AA.strNOG.ENOG411BE8B.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.069.AA.strNOG.ENOG411BE8B.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.069.AA.strNOG.ENOG411BE8B.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.069.AA.strNOG.ENOG411BE8B.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.069.AA.strNOG.ENOG411BE8B.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.069.AA.strNOG.ENOG411BE8B.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.069.AA.strNOG.ENOG411BE8B.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.069.AA.strNOG.ENOG411BE8B.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.069.AA.strNOG.ENOG411BE8B.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.069.AA.strNOG.ENOG411BE8B.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.069.AA.strNOG.ENOG411BE8B.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.069.AA.strNOG.ENOG411BE8B.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.069.AA.strNOG.ENOG411BE8B.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.069.AA.strNOG.ENOG411BE8B.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.069.AA.strNOG.ENOG411BE8B.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.069.AA.strNOG.ENOG411BE8B.fasta");

}

SCENARIO ("Alignment methods work correctly in example.070.AA.strNOG.ENOG411BEUV.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.070.AA.strNOG.ENOG411BEUV.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.070.AA.strNOG.ENOG411BEUV.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.070.AA.strNOG.ENOG411BEUV.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.070.AA.strNOG.ENOG411BEUV.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.070.AA.strNOG.ENOG411BEUV.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.070.AA.strNOG.ENOG411BEUV.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.070.AA.strNOG.ENOG411BEUV.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.070.AA.strNOG.ENOG411BEUV.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.070.AA.strNOG.ENOG411BEUV.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.070.AA.strNOG.ENOG411BEUV.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.070.AA.strNOG.ENOG411BEUV.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.070.AA.strNOG.ENOG411BEUV.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.070.AA.strNOG.ENOG411BEUV.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.070.AA.strNOG.ENOG411BEUV.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.070.AA.strNOG.ENOG411BEUV.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.070.AA.strNOG.ENOG411BEUV.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.070.AA.strNOG.ENOG411BEUV.fasta");

}

SCENARIO ("Alignment methods work correctly in example.071.AA.strNOG.ENOG411BEZ0.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.071.AA.strNOG.ENOG411BEZ0.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.071.AA.strNOG.ENOG411BEZ0.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.071.AA.strNOG.ENOG411BEZ0.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.071.AA.strNOG.ENOG411BEZ0.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.071.AA.strNOG.ENOG411BEZ0.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.071.AA.strNOG.ENOG411BEZ0.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.071.AA.strNOG.ENOG411BEZ0.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.071.AA.strNOG.ENOG411BEZ0.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.071.AA.strNOG.ENOG411BEZ0.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.071.AA.strNOG.ENOG411BEZ0.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.071.AA.strNOG.ENOG411BEZ0.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.071.AA.strNOG.ENOG411BEZ0.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.071.AA.strNOG.ENOG411BEZ0.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.071.AA.strNOG.ENOG411BEZ0.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.071.AA.strNOG.ENOG411BEZ0.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.071.AA.strNOG.ENOG411BEZ0.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.071.AA.strNOG.ENOG411BEZ0.fasta");

}

SCENARIO ("Alignment methods work correctly in example.072.AA.strNOG.ENOG411BF1S.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.072.AA.strNOG.ENOG411BF1S.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.072.AA.strNOG.ENOG411BF1S.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.072.AA.strNOG.ENOG411BF1S.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.072.AA.strNOG.ENOG411BF1S.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.072.AA.strNOG.ENOG411BF1S.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.072.AA.strNOG.ENOG411BF1S.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.072.AA.strNOG.ENOG411BF1S.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.072.AA.strNOG.ENOG411BF1S.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.072.AA.strNOG.ENOG411BF1S.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.072.AA.strNOG.ENOG411BF1S.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.072.AA.strNOG.ENOG411BF1S.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.072.AA.strNOG.ENOG411BF1S.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.072.AA.strNOG.ENOG411BF1S.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.072.AA.strNOG.ENOG411BF1S.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.072.AA.strNOG.ENOG411BF1S.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.072.AA.strNOG.ENOG411BF1S.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.072.AA.strNOG.ENOG411BF1S.fasta");

}

SCENARIO ("Alignment methods work correctly in example.073.AA.strNOG.ENOG411BFCW.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.073.AA.strNOG.ENOG411BFCW.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.073.AA.strNOG.ENOG411BFCW.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.073.AA.strNOG.ENOG411BFCW.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.073.AA.strNOG.ENOG411BFCW.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.073.AA.strNOG.ENOG411BFCW.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.073.AA.strNOG.ENOG411BFCW.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.073.AA.strNOG.ENOG411BFCW.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.073.AA.strNOG.ENOG411BFCW.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.073.AA.strNOG.ENOG411BFCW.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.073.AA.strNOG.ENOG411BFCW.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.073.AA.strNOG.ENOG411BFCW.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.073.AA.strNOG.ENOG411BFCW.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.073.AA.strNOG.ENOG411BFCW.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.073.AA.strNOG.ENOG411BFCW.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.073.AA.strNOG.ENOG411BFCW.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.073.AA.strNOG.ENOG411BFCW.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.073.AA.strNOG.ENOG411BFCW.fasta");

}

SCENARIO ("Alignment methods work correctly in example.074.AA.strNOG.ENOG411BFPF.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.074.AA.strNOG.ENOG411BFPF.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.074.AA.strNOG.ENOG411BFPF.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.074.AA.strNOG.ENOG411BFPF.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.074.AA.strNOG.ENOG411BFPF.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.074.AA.strNOG.ENOG411BFPF.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.074.AA.strNOG.ENOG411BFPF.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.074.AA.strNOG.ENOG411BFPF.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.074.AA.strNOG.ENOG411BFPF.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.074.AA.strNOG.ENOG411BFPF.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.074.AA.strNOG.ENOG411BFPF.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.074.AA.strNOG.ENOG411BFPF.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.074.AA.strNOG.ENOG411BFPF.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.074.AA.strNOG.ENOG411BFPF.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.074.AA.strNOG.ENOG411BFPF.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.074.AA.strNOG.ENOG411BFPF.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.074.AA.strNOG.ENOG411BFPF.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.074.AA.strNOG.ENOG411BFPF.fasta");

}

SCENARIO ("Alignment methods work correctly in example.075.AA.strNOG.ENOG411BFQS.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.075.AA.strNOG.ENOG411BFQS.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.075.AA.strNOG.ENOG411BFQS.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.075.AA.strNOG.ENOG411BFQS.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.075.AA.strNOG.ENOG411BFQS.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.075.AA.strNOG.ENOG411BFQS.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.075.AA.strNOG.ENOG411BFQS.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.075.AA.strNOG.ENOG411BFQS.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.075.AA.strNOG.ENOG411BFQS.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.075.AA.strNOG.ENOG411BFQS.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.075.AA.strNOG.ENOG411BFQS.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.075.AA.strNOG.ENOG411BFQS.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.075.AA.strNOG.ENOG411BFQS.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.075.AA.strNOG.ENOG411BFQS.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.075.AA.strNOG.ENOG411BFQS.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.075.AA.strNOG.ENOG411BFQS.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.075.AA.strNOG.ENOG411BFQS.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.075.AA.strNOG.ENOG411BFQS.fasta");

}

SCENARIO ("Alignment methods work correctly in example.075.AA.strNOG.ENOG411BFQS.nxs", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.075.AA.strNOG.ENOG411BFQS.nxs", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.075.AA.strNOG.ENOG411BFQS.nxs.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.075.AA.strNOG.ENOG411BFQS.nxs.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.075.AA.strNOG.ENOG411BFQS.nxs.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.075.AA.strNOG.ENOG411BFQS.nxs.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.075.AA.strNOG.ENOG411BFQS.nxs.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.075.AA.strNOG.ENOG411BFQS.nxs.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.075.AA.strNOG.ENOG411BFQS.nxs.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.075.AA.strNOG.ENOG411BFQS.nxs.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.075.AA.strNOG.ENOG411BFQS.nxs.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.075.AA.strNOG.ENOG411BFQS.nxs.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.075.AA.strNOG.ENOG411BFQS.nxs.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.075.AA.strNOG.ENOG411BFQS.nxs.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.075.AA.strNOG.ENOG411BFQS.nxs.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.075.AA.strNOG.ENOG411BFQS.nxs.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.075.AA.strNOG.ENOG411BFQS.nxs.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.075.AA.strNOG.ENOG411BFQS.nxs");

}

SCENARIO ("Alignment methods work correctly in example.076.AA.strNOG.ENOG411BH75.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.076.AA.strNOG.ENOG411BH75.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.076.AA.strNOG.ENOG411BH75.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.076.AA.strNOG.ENOG411BH75.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.076.AA.strNOG.ENOG411BH75.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.076.AA.strNOG.ENOG411BH75.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.076.AA.strNOG.ENOG411BH75.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.076.AA.strNOG.ENOG411BH75.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.076.AA.strNOG.ENOG411BH75.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.076.AA.strNOG.ENOG411BH75.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.076.AA.strNOG.ENOG411BH75.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.076.AA.strNOG.ENOG411BH75.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.076.AA.strNOG.ENOG411BH75.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.076.AA.strNOG.ENOG411BH75.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.076.AA.strNOG.ENOG411BH75.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.076.AA.strNOG.ENOG411BH75.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.076.AA.strNOG.ENOG411BH75.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.076.AA.strNOG.ENOG411BH75.fasta");

}

SCENARIO ("Alignment methods work correctly in example.077.AA.strNOG.ENOG411BH79.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.077.AA.strNOG.ENOG411BH79.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.077.AA.strNOG.ENOG411BH79.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.077.AA.strNOG.ENOG411BH79.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.077.AA.strNOG.ENOG411BH79.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.077.AA.strNOG.ENOG411BH79.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.077.AA.strNOG.ENOG411BH79.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.077.AA.strNOG.ENOG411BH79.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.077.AA.strNOG.ENOG411BH79.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.077.AA.strNOG.ENOG411BH79.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.077.AA.strNOG.ENOG411BH79.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.077.AA.strNOG.ENOG411BH79.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.077.AA.strNOG.ENOG411BH79.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.077.AA.strNOG.ENOG411BH79.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.077.AA.strNOG.ENOG411BH79.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.077.AA.strNOG.ENOG411BH79.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.077.AA.strNOG.ENOG411BH79.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.077.AA.strNOG.ENOG411BH79.fasta");

}

SCENARIO ("Alignment methods work correctly in example.078.AA.strNOG.ENOG411BH99.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.078.AA.strNOG.ENOG411BH99.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.078.AA.strNOG.ENOG411BH99.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.078.AA.strNOG.ENOG411BH99.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.078.AA.strNOG.ENOG411BH99.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.078.AA.strNOG.ENOG411BH99.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.078.AA.strNOG.ENOG411BH99.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.078.AA.strNOG.ENOG411BH99.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.078.AA.strNOG.ENOG411BH99.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.078.AA.strNOG.ENOG411BH99.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.078.AA.strNOG.ENOG411BH99.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.078.AA.strNOG.ENOG411BH99.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.078.AA.strNOG.ENOG411BH99.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.078.AA.strNOG.ENOG411BH99.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.078.AA.strNOG.ENOG411BH99.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.078.AA.strNOG.ENOG411BH99.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.078.AA.strNOG.ENOG411BH99.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.078.AA.strNOG.ENOG411BH99.fasta");

}

SCENARIO ("Alignment methods work correctly in example.079.AA.strNOG.ENOG411BJDC.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.079.AA.strNOG.ENOG411BJDC.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.079.AA.strNOG.ENOG411BJDC.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.079.AA.strNOG.ENOG411BJDC.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.079.AA.strNOG.ENOG411BJDC.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.079.AA.strNOG.ENOG411BJDC.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.079.AA.strNOG.ENOG411BJDC.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.079.AA.strNOG.ENOG411BJDC.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.079.AA.strNOG.ENOG411BJDC.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.079.AA.strNOG.ENOG411BJDC.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.079.AA.strNOG.ENOG411BJDC.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.079.AA.strNOG.ENOG411BJDC.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.079.AA.strNOG.ENOG411BJDC.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.079.AA.strNOG.ENOG411BJDC.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.079.AA.strNOG.ENOG411BJDC.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.079.AA.strNOG.ENOG411BJDC.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.079.AA.strNOG.ENOG411BJDC.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.079.AA.strNOG.ENOG411BJDC.fasta");

}

SCENARIO ("Alignment methods work correctly in example.080.AA.strNOG.ENOG411BJIF.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.080.AA.strNOG.ENOG411BJIF.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.080.AA.strNOG.ENOG411BJIF.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.080.AA.strNOG.ENOG411BJIF.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.080.AA.strNOG.ENOG411BJIF.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.080.AA.strNOG.ENOG411BJIF.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.080.AA.strNOG.ENOG411BJIF.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.080.AA.strNOG.ENOG411BJIF.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.080.AA.strNOG.ENOG411BJIF.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.080.AA.strNOG.ENOG411BJIF.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.080.AA.strNOG.ENOG411BJIF.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.080.AA.strNOG.ENOG411BJIF.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.080.AA.strNOG.ENOG411BJIF.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.080.AA.strNOG.ENOG411BJIF.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.080.AA.strNOG.ENOG411BJIF.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.080.AA.strNOG.ENOG411BJIF.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.080.AA.strNOG.ENOG411BJIF.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.080.AA.strNOG.ENOG411BJIF.fasta");

}

SCENARIO ("Alignment methods work correctly in example.081.AA.strNOG.ENOG411BK9X.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.081.AA.strNOG.ENOG411BK9X.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.081.AA.strNOG.ENOG411BK9X.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.081.AA.strNOG.ENOG411BK9X.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.081.AA.strNOG.ENOG411BK9X.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.081.AA.strNOG.ENOG411BK9X.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.081.AA.strNOG.ENOG411BK9X.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.081.AA.strNOG.ENOG411BK9X.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.081.AA.strNOG.ENOG411BK9X.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.081.AA.strNOG.ENOG411BK9X.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.081.AA.strNOG.ENOG411BK9X.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.081.AA.strNOG.ENOG411BK9X.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.081.AA.strNOG.ENOG411BK9X.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.081.AA.strNOG.ENOG411BK9X.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.081.AA.strNOG.ENOG411BK9X.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.081.AA.strNOG.ENOG411BK9X.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.081.AA.strNOG.ENOG411BK9X.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.081.AA.strNOG.ENOG411BK9X.fasta");

}

SCENARIO ("Alignment methods work correctly in example.082.AA.strNOG.ENOG411BKC5.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.082.AA.strNOG.ENOG411BKC5.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.082.AA.strNOG.ENOG411BKC5.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.082.AA.strNOG.ENOG411BKC5.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.082.AA.strNOG.ENOG411BKC5.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.082.AA.strNOG.ENOG411BKC5.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.082.AA.strNOG.ENOG411BKC5.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.082.AA.strNOG.ENOG411BKC5.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.082.AA.strNOG.ENOG411BKC5.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.082.AA.strNOG.ENOG411BKC5.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.082.AA.strNOG.ENOG411BKC5.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.082.AA.strNOG.ENOG411BKC5.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.082.AA.strNOG.ENOG411BKC5.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.082.AA.strNOG.ENOG411BKC5.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.082.AA.strNOG.ENOG411BKC5.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.082.AA.strNOG.ENOG411BKC5.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.082.AA.strNOG.ENOG411BKC5.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.082.AA.strNOG.ENOG411BKC5.fasta");

}

SCENARIO ("Alignment methods work correctly in example.083.AA.strNOG.ENOG411BMKC.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.083.AA.strNOG.ENOG411BMKC.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.083.AA.strNOG.ENOG411BMKC.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.083.AA.strNOG.ENOG411BMKC.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.083.AA.strNOG.ENOG411BMKC.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.083.AA.strNOG.ENOG411BMKC.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.083.AA.strNOG.ENOG411BMKC.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.083.AA.strNOG.ENOG411BMKC.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.083.AA.strNOG.ENOG411BMKC.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.083.AA.strNOG.ENOG411BMKC.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.083.AA.strNOG.ENOG411BMKC.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.083.AA.strNOG.ENOG411BMKC.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.083.AA.strNOG.ENOG411BMKC.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.083.AA.strNOG.ENOG411BMKC.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.083.AA.strNOG.ENOG411BMKC.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.083.AA.strNOG.ENOG411BMKC.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.083.AA.strNOG.ENOG411BMKC.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.083.AA.strNOG.ENOG411BMKC.fasta");

}

SCENARIO ("Alignment methods work correctly in example.084.AA.strNOG.ENOG411BNP9.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.084.AA.strNOG.ENOG411BNP9.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.084.AA.strNOG.ENOG411BNP9.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.084.AA.strNOG.ENOG411BNP9.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.084.AA.strNOG.ENOG411BNP9.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.084.AA.strNOG.ENOG411BNP9.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.084.AA.strNOG.ENOG411BNP9.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.084.AA.strNOG.ENOG411BNP9.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.084.AA.strNOG.ENOG411BNP9.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.084.AA.strNOG.ENOG411BNP9.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.084.AA.strNOG.ENOG411BNP9.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.084.AA.strNOG.ENOG411BNP9.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.084.AA.strNOG.ENOG411BNP9.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.084.AA.strNOG.ENOG411BNP9.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.084.AA.strNOG.ENOG411BNP9.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.084.AA.strNOG.ENOG411BNP9.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.084.AA.strNOG.ENOG411BNP9.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.084.AA.strNOG.ENOG411BNP9.fasta");

}

SCENARIO ("Alignment methods work correctly in example.085.AA.strNOG.ENOG411BQTJ.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.085.AA.strNOG.ENOG411BQTJ.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.085.AA.strNOG.ENOG411BQTJ.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.085.AA.strNOG.ENOG411BQTJ.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.085.AA.strNOG.ENOG411BQTJ.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.085.AA.strNOG.ENOG411BQTJ.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.085.AA.strNOG.ENOG411BQTJ.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.085.AA.strNOG.ENOG411BQTJ.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.085.AA.strNOG.ENOG411BQTJ.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.085.AA.strNOG.ENOG411BQTJ.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.085.AA.strNOG.ENOG411BQTJ.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.085.AA.strNOG.ENOG411BQTJ.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.085.AA.strNOG.ENOG411BQTJ.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.085.AA.strNOG.ENOG411BQTJ.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.085.AA.strNOG.ENOG411BQTJ.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.085.AA.strNOG.ENOG411BQTJ.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.085.AA.strNOG.ENOG411BQTJ.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.085.AA.strNOG.ENOG411BQTJ.fasta");

}

SCENARIO ("Alignment methods work correctly in example.086.AA.strNOG.ENOG411BR1D.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.086.AA.strNOG.ENOG411BR1D.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.086.AA.strNOG.ENOG411BR1D.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.086.AA.strNOG.ENOG411BR1D.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.086.AA.strNOG.ENOG411BR1D.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.086.AA.strNOG.ENOG411BR1D.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.086.AA.strNOG.ENOG411BR1D.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.086.AA.strNOG.ENOG411BR1D.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.086.AA.strNOG.ENOG411BR1D.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.086.AA.strNOG.ENOG411BR1D.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.086.AA.strNOG.ENOG411BR1D.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.086.AA.strNOG.ENOG411BR1D.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.086.AA.strNOG.ENOG411BR1D.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.086.AA.strNOG.ENOG411BR1D.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.086.AA.strNOG.ENOG411BR1D.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.086.AA.strNOG.ENOG411BR1D.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.086.AA.strNOG.ENOG411BR1D.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.086.AA.strNOG.ENOG411BR1D.fasta");

}

SCENARIO ("Alignment methods work correctly in example.087.AA.strNOG.ENOG411BRCH.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.087.AA.strNOG.ENOG411BRCH.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.087.AA.strNOG.ENOG411BRCH.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.087.AA.strNOG.ENOG411BRCH.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.087.AA.strNOG.ENOG411BRCH.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.087.AA.strNOG.ENOG411BRCH.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.087.AA.strNOG.ENOG411BRCH.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.087.AA.strNOG.ENOG411BRCH.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.087.AA.strNOG.ENOG411BRCH.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.087.AA.strNOG.ENOG411BRCH.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.087.AA.strNOG.ENOG411BRCH.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.087.AA.strNOG.ENOG411BRCH.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.087.AA.strNOG.ENOG411BRCH.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.087.AA.strNOG.ENOG411BRCH.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.087.AA.strNOG.ENOG411BRCH.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.087.AA.strNOG.ENOG411BRCH.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.087.AA.strNOG.ENOG411BRCH.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.087.AA.strNOG.ENOG411BRCH.fasta");

}

SCENARIO ("Alignment methods work correctly in example.088.AA.strNOG.ENOG411BSXF.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.088.AA.strNOG.ENOG411BSXF.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.088.AA.strNOG.ENOG411BSXF.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.088.AA.strNOG.ENOG411BSXF.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.088.AA.strNOG.ENOG411BSXF.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.088.AA.strNOG.ENOG411BSXF.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.088.AA.strNOG.ENOG411BSXF.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.088.AA.strNOG.ENOG411BSXF.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.088.AA.strNOG.ENOG411BSXF.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.088.AA.strNOG.ENOG411BSXF.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.088.AA.strNOG.ENOG411BSXF.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.088.AA.strNOG.ENOG411BSXF.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.088.AA.strNOG.ENOG411BSXF.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.088.AA.strNOG.ENOG411BSXF.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.088.AA.strNOG.ENOG411BSXF.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.088.AA.strNOG.ENOG411BSXF.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.088.AA.strNOG.ENOG411BSXF.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.088.AA.strNOG.ENOG411BSXF.fasta");

}

SCENARIO ("Alignment methods work correctly in example.089.AA.strNOG.ENOG411BV9B.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.089.AA.strNOG.ENOG411BV9B.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.089.AA.strNOG.ENOG411BV9B.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.089.AA.strNOG.ENOG411BV9B.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.089.AA.strNOG.ENOG411BV9B.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.089.AA.strNOG.ENOG411BV9B.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.089.AA.strNOG.ENOG411BV9B.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.089.AA.strNOG.ENOG411BV9B.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.089.AA.strNOG.ENOG411BV9B.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.089.AA.strNOG.ENOG411BV9B.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.089.AA.strNOG.ENOG411BV9B.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.089.AA.strNOG.ENOG411BV9B.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.089.AA.strNOG.ENOG411BV9B.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.089.AA.strNOG.ENOG411BV9B.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.089.AA.strNOG.ENOG411BV9B.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.089.AA.strNOG.ENOG411BV9B.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.089.AA.strNOG.ENOG411BV9B.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.089.AA.strNOG.ENOG411BV9B.fasta");

}

SCENARIO ("Alignment methods work correctly in example.090.AA.strNOG.ENOG411BVKR.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.090.AA.strNOG.ENOG411BVKR.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.090.AA.strNOG.ENOG411BVKR.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.090.AA.strNOG.ENOG411BVKR.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.090.AA.strNOG.ENOG411BVKR.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.090.AA.strNOG.ENOG411BVKR.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.090.AA.strNOG.ENOG411BVKR.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.090.AA.strNOG.ENOG411BVKR.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.090.AA.strNOG.ENOG411BVKR.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.090.AA.strNOG.ENOG411BVKR.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.090.AA.strNOG.ENOG411BVKR.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.090.AA.strNOG.ENOG411BVKR.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.090.AA.strNOG.ENOG411BVKR.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.090.AA.strNOG.ENOG411BVKR.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.090.AA.strNOG.ENOG411BVKR.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.090.AA.strNOG.ENOG411BVKR.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.090.AA.strNOG.ENOG411BVKR.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.090.AA.strNOG.ENOG411BVKR.fasta");

}

SCENARIO ("Alignment methods work correctly in example.091.AA.strNOG.ENOG411BWBU.codon.fa", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.091.AA.strNOG.ENOG411BWBU.codon.fa", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.091.AA.strNOG.ENOG411BWBU.codon.fa.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.091.AA.strNOG.ENOG411BWBU.codon.fa.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.091.AA.strNOG.ENOG411BWBU.codon.fa.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.091.AA.strNOG.ENOG411BWBU.codon.fa.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.091.AA.strNOG.ENOG411BWBU.codon.fa.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.091.AA.strNOG.ENOG411BWBU.codon.fa.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.091.AA.strNOG.ENOG411BWBU.codon.fa.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.091.AA.strNOG.ENOG411BWBU.codon.fa.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.091.AA.strNOG.ENOG411BWBU.codon.fa.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.091.AA.strNOG.ENOG411BWBU.codon.fa.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.091.AA.strNOG.ENOG411BWBU.codon.fa.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.091.AA.strNOG.ENOG411BWBU.codon.fa.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.091.AA.strNOG.ENOG411BWBU.codon.fa.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.091.AA.strNOG.ENOG411BWBU.codon.fa.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.091.AA.strNOG.ENOG411BWBU.codon.fa.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.091.AA.strNOG.ENOG411BWBU.codon.fa");

}

SCENARIO ("Alignment methods work correctly in example.091.AA.strNOG.ENOG411BWBU.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.091.AA.strNOG.ENOG411BWBU.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.091.AA.strNOG.ENOG411BWBU.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.091.AA.strNOG.ENOG411BWBU.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.091.AA.strNOG.ENOG411BWBU.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.091.AA.strNOG.ENOG411BWBU.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.091.AA.strNOG.ENOG411BWBU.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.091.AA.strNOG.ENOG411BWBU.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.091.AA.strNOG.ENOG411BWBU.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.091.AA.strNOG.ENOG411BWBU.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.091.AA.strNOG.ENOG411BWBU.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.091.AA.strNOG.ENOG411BWBU.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.091.AA.strNOG.ENOG411BWBU.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.091.AA.strNOG.ENOG411BWBU.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.091.AA.strNOG.ENOG411BWBU.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.091.AA.strNOG.ENOG411BWBU.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.091.AA.strNOG.ENOG411BWBU.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.091.AA.strNOG.ENOG411BWBU.fasta");

}

SCENARIO ("Alignment methods work correctly in example.092.DNA.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.092.DNA.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.092.DNA.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.092.DNA.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.092.DNA.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.092.DNA.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.092.DNA.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.092.DNA.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.092.DNA.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.092.DNA.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.092.DNA.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.092.DNA.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.092.DNA.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.092.DNA.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.092.DNA.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.092.DNA.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.092.DNA.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.092.DNA.fasta");

}

SCENARIO ("Alignment methods work correctly in example.093.DNA.fasta", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.093.DNA.fasta", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.093.DNA.fasta.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.093.DNA.fasta.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.093.DNA.fasta.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.093.DNA.fasta.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.093.DNA.fasta.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.093.DNA.fasta.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.093.DNA.fasta.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.093.DNA.fasta.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.093.DNA.fasta.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.093.DNA.fasta.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.093.DNA.fasta.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.093.DNA.fasta.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.093.DNA.fasta.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.093.DNA.fasta.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.093.DNA.fasta.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.093.DNA.fasta");

}

SCENARIO ("Alignment methods work correctly in example.094.DNADeg.sequential_phy", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("example.094.DNADeg.sequential_phy", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/example.094.DNADeg.sequential_phy.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.094.DNADeg.sequential_phy.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.094.DNADeg.sequential_phy.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/example.094.DNADeg.sequential_phy.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.094.DNADeg.sequential_phy.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.094.DNADeg.sequential_phy.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.094.DNADeg.sequential_phy.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.094.DNADeg.sequential_phy.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/example.094.DNADeg.sequential_phy.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/example.094.DNADeg.sequential_phy.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.094.DNADeg.sequential_phy.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/example.094.DNADeg.sequential_phy.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.094.DNADeg.sequential_phy.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/example.094.DNADeg.sequential_phy.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/example.094.DNADeg.sequential_phy.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from example.094.DNADeg.sequential_phy");

}

SCENARIO ("Alignment methods work correctly in matrix.BLOSUM62", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("matrix.BLOSUM62", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/matrix.BLOSUM62.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/matrix.BLOSUM62.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/matrix.BLOSUM62.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/matrix.BLOSUM62.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/matrix.BLOSUM62.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/matrix.BLOSUM62.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/matrix.BLOSUM62.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/matrix.BLOSUM62.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/matrix.BLOSUM62.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/matrix.BLOSUM62.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/matrix.BLOSUM62.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/matrix.BLOSUM62.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/matrix.BLOSUM62.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/matrix.BLOSUM62.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/matrix.BLOSUM62.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from matrix.BLOSUM62");

}

SCENARIO ("Alignment methods work correctly in matrix.Degenerated_DNA", "[alignment][aligMethods]") {
    static picojson::value testData;

    newAlignment alig;

    if (loadJSON("matrix.Degenerated_DNA", testData)) {

        alig.sequenNumber = testData.get("sequenNumber").get<double>();
        alig.originalSequenNumber = alig.sequenNumber;
        alig.residNumber = testData.get("residNumber").get<double>();
        alig.originalResidNumber = alig.residNumber;
        alig.isAligned = testData.get("aligned").get<bool>();

        populate(alig.sequences, testData.get("sequences"));
        populate(alig.seqsName, testData.get("names"));

        alig.fillMatrices(alig.isAligned);

        WHEN ("Checking save residues is initialized correctly") {

            if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {

                int *saveResidues = new int[alig.residNumber];
                for (i = 0; i < alig.residNumber; i++) {
                    saveResidues[i] = i;
                }

                REQUIRE (alig.saveResidues != NULL);

                INFO ("Save residues array in alignment doesn't match with expected saveResidues");
                auto expected =
                        std::vector<int>(saveResidues,
                                         saveResidues + alig.residNumber);

                CAPTURE (expected);

                auto obtained =
                        std::vector<int>(alig.saveResidues,
                                         alig.saveResidues + alig.residNumber);

                CAPTURE (obtained);

                REQUIRE_THAT (alig.saveResidues,
                              ArrayContentsEqual(saveResidues,
                                                 alig.residNumber,
                                                 "./dataset/testingFiles/alignmentErrors/matrix.Degenerated_DNA.saveResidues.error.tsv"));

                delete[] saveResidues;
            }
        }

        WHEN ("Getting number of species") {
            REQUIRE (alig.getNumSpecies() ==
                     testData.get("sequenNumber").get<double>());
        }

        WHEN ("Getting number of residues") {
            REQUIRE (alig.getNumAminos() ==
                     testData.get("residNumber").get<double>());
        }

        WHEN("Choosing an automated method")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    // TODO Clean this. We shouldn't be casting. The original value should be in int, not string.
                    REQUIRE(std::to_string(alig.Cleaning->selectMethod()) == testData.get("AutoMethod").get<string>());
                }
            }
        }

        WHEN("Calculating Cons Vectors")
        {
            if (testData.contains("aligned")) {
                if (testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    alig.sgaps = new statisticsGaps(&alig);
                    int SequenceType = testData.get("SequenceType").get<double>();
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);
                    alig.scons->calculateVectors(alig.sgaps->getGapsWindow());

                    WHEN("Calculating MDK")
                    {
                        float * mdk_expected;
                        populate(mdk_expected, testData.get("mdk"));

                        float * mdk_obtained = alig.scons->getMdkwVector();

                        REQUIRE(mdk_obtained != NULL);

                        REQUIRE_THAT(mdk_obtained,
                                     ArrayContentsEqual(mdk_expected,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/matrix.Degenerated_DNA.MDK.error.tsv"));
                        delete [] mdk_expected;
                        delete [] mdk_obtained;
                    }

                    WHEN("Calculating Q")
                    {
                        float * Q_expected;
                        populate(Q_expected, testData.get("Q"));

                        float * Q_obtained = alig.scons->Q;

                        REQUIRE(Q_obtained != NULL);

                        REQUIRE_THAT(Q_expected,
                                     ArrayContentsEqual(Q_obtained,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/matrix.Degenerated_DNA.Q.error.tsv"));
                        delete [] Q_expected;
//                        delete [] Q_obtained;
                    }
                }
            }
        }

        WHEN("Getting alignment type")
        {
            // TODO Result JSON should include the new mapping ids of SequenceTypes instead of the original.
            REQUIRE(alig.getAlignmentType() == AlignmentTypeCorrespondence[static_cast<int>(testData.get("SequenceType").get<double>())]);
        }

        WHEN ("Getting Sequences") {

            if (testData.contains("names")) {
                string *names = new string[alig.sequenNumber],
                        *expectedNames;
                populate(expectedNames, testData.get("names"));

                GIVEN ("Out names") {

                    alig.getSequences(names);

                    REQUIRE_THAT (names,
                                  ArrayContentsEqual(expectedNames,
                                                     alig.sequenNumber,
                                                     "./dataset/testingFiles/alignmentErrors/matrix.Degenerated_DNA.names1.error.tsv"));
                }

                if (testData.contains("noGapsSize")) {
                    int *sizePerSequence = new int[alig.sequenNumber],
                            *expectedSizePerSequence;
                    populate(expectedSizePerSequence, testData.get("noGapsSize"));

                    GIVEN ("Out names and out lengths") {

                        alig.getSequences(names,
                                          sizePerSequence);

                        REQUIRE_THAT (names,
                                      ArrayContentsEqual(expectedNames,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/matrix.Degenerated_DNA.names2.error.tsv"));

                        REQUIRE_THAT (sizePerSequence,
                                      ArrayContentsEqual(expectedSizePerSequence,
                                                         alig.sequenNumber,
                                                         "./dataset/testingFiles/alignmentErrors/matrix.Degenerated_DNA.sizePerSequence1.error.tsv"));
                    }

                    if (testData.contains("noGapsSequences")) {
                        string *sequences = new string[alig.sequenNumber],
                                *expectedSequences;
                        populate(expectedSequences,
                                 testData.get("noGapsSequences"));

                        GIVEN ("Out names, out sequences, out lengths") {
                            alig.getSequences(names,
                                              sequences,
                                              sizePerSequence);

                            REQUIRE_THAT (names,
                                          ArrayContentsEqual(expectedNames,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/matrix.Degenerated_DNA.names4.error.tsv"));

                            REQUIRE_THAT (sizePerSequence,
                                          ArrayContentsEqual(expectedSizePerSequence,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/matrix.Degenerated_DNA.sizePerSequence2.error.tsv"));

                            REQUIRE_THAT (sequences,
                                          ArrayContentsEqual(expectedSequences,
                                                             alig.sequenNumber,
                                                             "./dataset/testingFiles/alignmentErrors/matrix.Degenerated_DNA.sequences.error.tsv"));
                        }

                        delete[] sequences;
                        delete[] expectedSequences;
                    } else
                        WARN ("Alignment testfile does not contain 'sequences' variable."
                                      "\nSkipping test 'Out string array, out sequences, out lengths'");
                    delete[] sizePerSequence;
                    delete[] expectedSizePerSequence;
                } else
                    WARN ("Alignment testfile does not contain 'noGapsSize' variable."
                                  "\nSkipping test 'Out string array and out lengths'");
                delete[] names;
                delete[] expectedNames;
            } else
                WARN ("Alignment testfile does not contain 'names' variable."
                              "\nSkipping test 'Out string array'");


        }

        WHEN ("Calculating Gaps per column") {
            if (testData.contains("gapsPerColumn")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *GapsPerColumn = alig.sgaps->getGapsWindow(), *expectedGapsPerColumn;
                        populate(expectedGapsPerColumn, testData.get("gapsPerColumn"));

                        REQUIRE_THAT (GapsPerColumn,
                                      ArrayContentsEqual(expectedGapsPerColumn,
                                                         alig.residNumber,
                                                         "./dataset/testingFiles/alignmentErrors/matrix.Degenerated_DNA.gapsPerColumn.error.tsv"));

                        delete[] expectedGapsPerColumn;
                    } //else WARN ( "Alignment testfile is not aligned.\nSkipping test 'Calculate Gaps'" );
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by No All Gaps") {
            if (testData.contains("cleanNoAllGaps")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("cleanNoAllGaps"));

                        newAlignment *newAl = alig.Cleaning->cleanNoAllGaps(false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/matrix.Degenerated_DNA.noAllGaps.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean 2nd Slope") {
            if (testData.contains("clean2ndSlope")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        alig.sgaps = new statisticsGaps(&alig);

                        WHEN("Calculating 2nd Slope")
                            CHECK(alig.sgaps->calcCutPoint2ndSlope() == testData.get("2ndSlopeCutPoint").get<double>());

                        WHEN("Applying 2nd Slope")
                        {
                            int *cleanNoAllGaps;
                            populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                            newAlignment *newAl = alig.Cleaning->clean2ndSlope(false);

                            REQUIRE_THAT(newAl->saveResidues,
                                         ArrayContentsEqual(cleanNoAllGaps,
                                                            alig.residNumber,
                                                            "./dataset/testingFiles/alignmentErrors/matrix.Degenerated_DNA.2ndSlope.error.tsv"));
                            delete newAl;
                            delete[] cleanNoAllGaps;
                        }
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Lax") {
            if (testData.contains("cleanCombMethods lax")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, true);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/matrix.Degenerated_DNA.combMethodLax.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN ("Trimming by Clean Comb Methods Strict") {
            if (testData.contains("cleanCombMethods strict")) {
                if (testData.contains("aligned")) {
                    if (testData.get("aligned").get<bool>()) {
                        {
                            alig.sgaps = new statisticsGaps(&alig);
                            alig.scons = new statisticsConservation2(&alig);
                            int SequenceType = testData.get("SequenceType").get<double>();
                            similarityMatrix *sm = new similarityMatrix();
                            switch (SequenceType) {
                                case 1: case 2: default:
                                    sm->defaultNTSimMatrix(); break;
                                case 3:
                                    sm->defaultAASimMatrix(); break;
                                case 4: case 5:
                                    sm->defaultNTDegeneratedSimMatrix(); break;
                            }
                            alig.scons->setSimilarityMatrix(sm);
                        }
                        int *cleanNoAllGaps;
                        populate(cleanNoAllGaps, testData.get("clean2ndSlope"));

                        newAlignment *newAl = alig.Cleaning->cleanCombMethods(false, false);

                        REQUIRE_THAT(newAl->saveResidues,
                                     ArrayContentsEqual(cleanNoAllGaps,
                                                        alig.residNumber,
                                                        "./dataset/testingFiles/alignmentErrors/matrix.Degenerated_DNA.combMethodStrict.error.tsv"));
                        delete newAl;
                        delete[] cleanNoAllGaps;
                    }
                } else
                    WARN ("Alignment testfile does not contain 'aligned' variable"
                                  "\nSkipping test 'Calculate Gaps'");
            } else
                WARN ("Alignment testfile does not contain 'gapsPerColumn' variable"
                              "\nSkipping test 'Calculate Gaps'");
        }

        WHEN("Trimming by Clean Gaps") {
            if (testData.contains("cleanGaps")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.sgaps = new statisticsGaps(&alig);
                    auto cleanGapsData = testData.get("cleanGaps").get<picojson::object>();
                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto gapPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 gapPctIT != end2;
                                 gapPctIT++)
                            {
                                GIVEN(gapPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float gapsPct = std::stof(gapPctIT->first.substr(gapPctIT->first.find('=') + 1));
                                    int *saveResidues;
                                    populate(saveResidues, gapPctIT->second);

                                    newAlignment *newAl = alig.Cleaning->cleanGaps(baseline, gapsPct, false);

                                    std::stringstream ss;
                                    ss << "./dataset/testingFiles/alignmentErrors/matrix.Degenerated_DNA.CleanGaps"
                                       << ".BL" << std::to_string(baseline)
                                       << ".GPCT" << std::to_string(gapsPct)
                                       << ".error.tsv";

                                    REQUIRE_THAT(newAl->saveResidues,
                                                 ArrayContentsEqual(saveResidues,
                                                                    newAl->residNumber,
                                                                    ss.rdbuf()->str()));

                                    delete newAl;

                                    delete[] saveResidues;
                                }
                            }
                        }
                    }
                }
            }
        }

        WHEN("Calculating consCutPoint") {
            if (testData.contains("consCutPoint")) {
                if (testData.contains("aligned") && testData.get("aligned").get<bool>()) {
                    alig.scons = new statisticsConservation2(&alig);
                    int SequenceType = static_cast<int>(testData.get("SequenceType").get<double>());
                    similarityMatrix *sm = new similarityMatrix();
                    switch (SequenceType) {
                        case 1: case 2: default:
                            sm->defaultNTSimMatrix(); break;
                        case 3:
                            sm->defaultAASimMatrix(); break;
                        case 4: case 5:
                            sm->defaultNTDegeneratedSimMatrix(); break;
                    }
                    alig.scons->setSimilarityMatrix(sm);

                    auto cleanGapsData = testData.get("consCutPoint").get<picojson::object>();

                    for (auto baselineIT = cleanGapsData.begin(), end = cleanGapsData.end(); baselineIT != end; baselineIT++) {
                        GIVEN (baselineIT->first) {
                            auto cleanGapsDataSecondLevel = baselineIT->second.get<picojson::object>();
                            for (auto conPctIT = cleanGapsDataSecondLevel.begin(), end2 = cleanGapsDataSecondLevel.end();
                                 conPctIT != end2;
                                 conPctIT++) {
                                GIVEN(conPctIT->first) {
                                    float baseline = std::stof(baselineIT->first.substr(baselineIT->first.find('=') + 1));
                                    float consPct = std::stof(conPctIT->first.substr(conPctIT->first.find('=') + 1));

                                    REQUIRE(alig.scons->calcCutPoint(baseline, consPct) == conPctIT->second.get<double>());
                                }
                            }
                        }
                    }

                }
            }
        }
    } else
        WARN("No Expected Test Results from matrix.Degenerated_DNA");

}

